

[TOC]

#### 1、在main执行之前和之后执行的代码可能是什么？

> **main****函数执行之前**，主要就是<u>初始化系统相关资源</u>**：
>
> - ==**<u>设置栈指针</u>**==
>
> - <u>==初始化**静态static变量**和**global全局变量**，即.**data段的内容==**</u>
>
> - 将<u>**==未初始化部分的全局变量赋初值==**</u>：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即<u>**==.bss段的内容==**</u> 
>
>
> - <u>**==全局对象初始化==**，在main之前**==调用构造函数==**</u>，这是可能会执行前的一些代码<u>将**==main函数的参数argc，argv等传递给main函数==**</u>，然后才真正运行main函数
>
> - <u>__attribute__((constructor))</u>
>
> 
>
> **main****函数执行之后**： 
>
> - **==全局对象的析构函数会在main函数之后执行==**；//pac
>
> - 可以用 **atexit** 注册一个函数，它会在main 之后执行;//pac
>
>
> - __attribute__((destructor))

#### 2、结构体内存对齐问题？

> https://cloud.tencent.com/developer/article/1727794
>
> http://www.feihuo-tech.net:8090/pages/viewpage.action?pageId=30638624

##### **1、什么是内存对齐**

> 还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。
>

```cpp
//32位系统
#include<stdio.h>
struct{
int x;
char y;
}s;
int main()
{
printf("%d\n",sizeof(s);  // 输出8
return 0;
}
```

> 现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

##### 2、内存对齐的单位

> 通过上面的分析，知道内存对齐的目的是为了让CPU能一次获取到数据，从而提升性能。学过汇编会了解，CPU只能使用基本类型，char, short, int, long, float, double 等，不能使用数组或结构体等复合类型（汇编中并没有一个指令能直接存取一个struct或数组）。所以：内存对齐的单位是基本类型，目标是让CPU能一次获取到基本类型的值。
>

##### 3、内存对齐的原则

> **先让我们看四个重要的基本概念：**
>
> |                  | 32位 | 64位         |
> | ---------------- | ---- | ------------ |
> | char             | 1    | 1            |
> | short int(short) | 2    | 2            |
> | int              | 4    | 多数4，少数8 |
> | long int (long)  | 4    | 8            |
> | long long        | 8    | 8            |
> | float            | 4    | 4            |
> | double           | 8    | 8            |
> | 指针             | 4    | 8            |
>
> **1.==数据类型自身的对齐值==：**
> **对于char型数据，其自身对齐值为1，对于short型为2，对于int,float，其自身对齐值为4，单位字节。double类型8字节**
> **2.==结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值==。**
> **3.==指定对齐值==：==#pragma pack (value)时的指定对齐值value==。**
> **4.数据成员、结构体和类的==有效对齐值：自身对齐值和指定对齐值中小的那个值==。**
>
> 
>
> **struct/class/union内存对齐原则有四个：**
>
> 1).数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，**==pac:以后每个成员相对于结构体首地址的 offset <u>都是该成员大小与有效对齐值中较小那个的整数倍==</u>**，如有需要编译器会在成员之间加上填充字节。(比如int在３２位机为４字节,指定对齐值是2， 则要从2的整数倍地址开始存储，char 自身对齐值是 1，指定对齐值是2，则要从1的整数倍开始),基本类型不包struct/class/uinon。
>
> 2).收尾工作:==**结构体的总大小**为 有效对齐值 的**整数倍**==，如有需要编译器会在最末一个成员之后加上填充字节。(基本类型不包括struct/class/uinon)。
>
> 3).sizeof(union)，以结构里面size最大元素的整数倍为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。
>
> 下面给出几个例子以便于理解：
>
> ```cpp
> //32位系统
> #include<stdio.h>
> struct
> {
> int c1;    //自身对齐和有效对齐值较小的整数倍,所以c1:0-4存
> char c2;  //c2: 4-5存
> char c3;  //c3: 5-6，剩下6-8空闲补齐，共8字节
> }x1;
> struct{
> char c1;  //c1：0-1存,1-4空闲
> int c2;    //c2: 4 - 8存
> char c3;  //c3:8-9存, 9-12空闲，共12字节
> }x2;
> 
> struct{
> char c1;  //c1: 0-1存
> char c2; //c2:1-2存  2-4空闲
> int c3;   //c3:4-8存，共8字节
> }x3;
> 
> int main()
> {
> printf("%d\n",sizeof(x1));  // 输出8
> printf("%d\n",sizeof(x2));  // 输出12
> printf("%d\n",sizeof(x3));  // 输出8
> return 0;
> }
> ```
>
> 以上测试都是在Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以s2来分析其内存布局：
>
> 首先使用规则1，对成员变量进行对齐：
>
> sizeof(c1) = 1 <= 4(有效对齐位)，按照1字节对齐，占用第0单元；
>
> sizeof(i) = 4 <= 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；
>
> sizeof(c2) = 1 <= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；
>
> 然后使用规则2，对结构体整体进行对齐：
>
> s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。
>

##### 4、#pragma pack(n)

> 不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。
>
> 例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。
>
> 如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：
>
> 经过上面的实例分析，大家应该对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。

##### 5、内存对齐的作用

> 1、 **平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。**
>
> 
>
> **2、 性能原因：经过内存对齐后，CPU的内存访问速度大大提升**。具体原因稍后解释。
>
> 
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast.jpeg)
>
> 这是普通程序员心目中的内存印象，由一个个的字节组成，而CPU并不是这么看待的。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483481.jpeg)
>
> CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为memory access granularity（粒度） 本人把它翻译为“内存读取粒度” 。
>
> 假设CPU要读取一个int型4字节大小的数据到寄存器中，分两种情况讨论：
>
> 1、数据从0字节开始
>
> 2、数据从1字节开始
>
> 再次假设内存读取粒度为4。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483482.jpeg)
>
> 当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。
>
> 当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483493.jpeg)
>
> 此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。
>
> 这还属于乐观情况了，上文提到内存对齐的作用之一为平台的移植原因，因为以上操作只有有部分CPU肯干，其他一部分CPU遇到未对齐边界就直接罢工了。

> sizeof(Info)求的是结构体元素的大小，而alignof(Info)求的是结构体有效对齐值
>
> 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
>
> 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）
>
> c++11以后引入两个关键字 alignas与 alignof。其中alignof可以计算出类型的对齐方式，alignas可以指
>
> 定结构体的对齐方式。
>
> 但是alignas在某些情况下是不能使用的，具体见下面的例子:
>
> ```cpp
> // alignas 生效的情况
> 
> struct Info {
> 
> uint8_t a;//同上，默认情况下：min(1,2) 0-1存，1-2空闲			alignof(4)情况下：min(1,4),0-1存，1-2空闲
> 
> uint16_t b;//min(2,4) 2-4存										    min(2,4),	2-4存，						
> uint8_t c;//4-5存，5-6空闲，共占6字节。			 min(1,4),4-5存，因为struct应该是(类中数据类型最大的对齐值与指定对齐值中较小值的整数倍)，5-8空闲，共占8字节
>     
> };
> 
> std::cout << sizeof(Info) << std::endl; // 6 2 + 2 + 2， uint8_t占用1字节，但是按照内存对齐按照默认最大的成员 uint16_t b;占用2字节，所以a也需要按照对齐，占用2字节，所以为2+2+2
> 
> std::cout << alignof(Info) << std::endl; // 2：求得内存对齐的大小：为uint16_t b;占用2字节：2
> 
> struct alignas(4) Info2 {//将默认对齐大小变为4，那么uint8_t a对应;+uint16_t b;加一起才3字节，都可以放到4字节中，
> //pac!!!每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍,那么uint8_t a占用0-1字节，uint16_t b起始地址是min(2,4) = 2所以占用 2-3字节.
> uint8_t a;//占用[0-1]中的0字节，
> 
> uint16_t b;//pac!!!首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍,所以占用2-3字节
> 
> uint8_t c;//而uint8_t c单独占用[4-7]中的4字节。所以ab一组占用4，后面c单独一组占用4 ：4+4
> 
> };
> 
> std::cout << sizeof(Info2) << std::endl; // 8 4 + 4
> 
> std::cout << alignof(Info2) << std::endl; // 4
> 
> alignas将内存对齐调整为4个字节。所以sizeof(Info2)的值变为了8。
> 
> 
> ```
>
> ```cpp
> // alignas 失效的情况
> 
> struct Info {
> 
> uint8_t a;
> 
> uint32_t b;
> 
> uint8_t c;
> 
> };
> 
> std::cout << sizeof(Info) << std::endl; // 12 4 + 4 + 4
> 
> std::cout << alignof(Info) << std::endl; // 4
> 
> struct alignas(2) Info2 {//指定小于最大，无效
> 
> uint8_t a;
> 
> uint32_t b;
> 
> uint8_t c;
> 
> };
> 
> std::cout << sizeof(Info2) << std::endl; // 12 4 + 4 + 4
> 
> std::cout << alignof(Info2) << std::endl; // 4
> ```
>
> 
>
> **==若alignas小于自然对齐的最小单位，则被忽略==。**
>
> 如果想使用单字节对齐的方式，使用alignas是无效的。应该使用#pragma pack(push,1)或者使用
>
> __attribute__((packed))。

```cpp
//#下面没太看懂为什么std::cout << alignof(Info) << std::endl; // 6
#if defined(__GNUC__) || defined(__GNUG__)
 #define ONEBYTE_ALIGN __attribute__((packed))
#elif defined(_MSC_VER)
 #define ONEBYTE_ALIGN
 #pragma pack(push,1)
#endif
struct Info {
 uint8_t a;
 uint32_t b;
 uint8_t c;
} ONEBYTE_ALIGN;
#if defined(__GNUC__) || defined(__GNUG__)
 #undef ONEBYTE_ALIGN
#elif defined(_MSC_VER)
 #pragma pack(pop)
 #undef ONEBYTE_ALIGN
#endif
std::cout << sizeof(Info) << std::endl; // 6 1 + 4 + 1
std::cout << alignof(Info) << std::endl; // 6
```

```cpp
//#下面没太看懂为什么std::cout << sizeof(Info) << std::endl; // 2
//std::cout << alignof(Info) << std::endl; // 1
确定结构体中每个元素大小可以通过下面这种方法:
这种处理方式是alignas处理不了的。
#if defined(__GNUC__) || defined(__GNUG__)
 #define ONEBYTE_ALIGN __attribute__((packed))
#elif defined(_MSC_VER)
 #define ONEBYTE_ALIGN
 #pragma pack(push,1)
#endif
/**
* 0 1 3 6 8 9 15
* +-+---+-----+---+-+-------------+
* | | | | | | |
* |a| b | c | d |e| pad |
* | | | | | | |
* +-+---+-----+---+-+-------------+
*/
struct Info {
 uint16_t a : 1;
 uint16_t b : 2;
 uint16_t c : 3;
 uint16_t d : 2;
 uint16_t e : 1;
 uint16_t pad : 7;
} ONEBYTE_ALIGN;
#if defined(__GNUC__) || defined(__GNUG__)
 #undef ONEBYTE_ALIGN
#elif defined(_MSC_VER)
 #pragma pack(pop)
 #undef ONEBYTE_ALIGN
#endif
std::cout << sizeof(Info) << std::endl; // 2
std::cout << alignof(Info) << std::endl; // 1
```

#### 3、指针和引用的区别

[指针和引用的区别](E:\笔记\c++\关键字和运算符.md)

> 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
>
> 指针可以有多级，引用只有一级
>
> 指针可以为空，引用不能为NULL且在定义时必须初始化
>
> 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
>
> sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
>
> 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同
>
> 一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
>
> 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要
>
> 具体分析）。
>
> 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和
>
> 定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
>
> 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指
>
> 针变量可以重新指向别的变量。
>
> 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
>
> ```cpp
> \#if defined(__GNUC__) || defined(__GNUG__)
> 
> \#define ONEBYTE_ALIGN __attribute__((packed))
> 
> \#elif defined(_MSC_VER)
> 
> \#define ONEBYTE_ALIGN
> 
> \#pragma pack(push,1)
> 
> \#endif
> 
> /**
> 
> \* 0 1 3 6 8 9 15
> 
> \* +-+---+-----+---+-+-------------+
> 
> \* | | | | | | |
> 
> \* |a| b | c | d |e| pad |
> 
> \* | | | | | | |
> 
> \* +-+---+-----+---+-+-------------+
> 
> */
> 
> struct Info {
> 
> uint16_t a : 1;//代表占用的
> 
> uint16_t b : 2;
> 
> uint16_t c : 3;
> 
> uint16_t d : 2;
> 
> uint16_t e : 1;
> 
> uint16_t pad : 7;
> 
> } ONEBYTE_ALIGN;
> 
> \#if defined(__GNUC__) || defined(__GNUG__)
> 
> \#undef ONEBYTE_ALIGN
> 
> \#elif defined(_MSC_VER)
> 
> \#pragma pack(pop)
> 
> \#undef ONEBYTE_ALIGN
> 
> \#endif
> 
> std::cout << sizeof(Info) << std::endl; // 2
> 
> std::cout << alignof(Info) << std::endl; // 1
> 
> **33**参考代码：
> 
> void test(int *p) 
> 
> {
> 
> int a=1;
> 
> p=&a;
> 
> cout<<p<<" "<<*p<<endl; 
> 
> }
> 
> int main(void) 
> 
> {
> 
> int *p=NULL;
> 
> test(p);
> 
> if(p==NULL)
> 
> cout<<"指针p为NULL"<<endl;
> 
> return 0; 
> 
> }
> 
> //运行结果为：
> 
> //0x22ff44 1
> 
> //指针p为NULL
> 
> void testPTR(int* p) {
> 
> int a = 12;
> 
> p = &a; 
> 
> }
> 
> void testREFF(int& p) {
> 
> int a = 12;
> 
> p = a; 
> 
> }
> 
> void main()
> 
> {
> 
> int a = 10;
> 
> int* b = &a;
> 
> testPTR(b);//改变指针指向，但是没改变指针的所指的内容
> 
> cout << a << endl;// 10
> 
> cout << *b << endl;// 10
> 
> a = 10;
> 
> testREFF(a);
> 
> cout << a << endl;//12
> 
> }
> ```
>
> 
>
> 在编译器看来, int a = 10; int &b = a; 等价于 int * const b = &a; 而 b = 20; 等价于 *b = 20; 自动转换为指针
>
> 和自动解引用

```cpp
#include<bits/stdc++.h>//指针类型无论char.int.double都是8字节。
using namespace  std;
int main(){
     char a = 0;//int double
     char &b = a;
     char *p = &a;
    
     cout<<sizeof a<< sizeof b <<sizeof p<<endl;
    return 0;
}
// int char double
// 448 118 888
```



#### 4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

> 1.需要**==返回==函数内==局部变量的内存==**的时候==用指针==。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而==返回局部变量的引用是没有意义的==
>
> 2.对**==栈空间大小==比较敏感**（比如递归）的时候使用==引用==。使用**==引用传递不需要创建临时变量==，==开销要更小==**
>
> 3.**<u>==类对象作为参数传递的时候使用引用==</u>**，这是C++类对象传递的标准方式//pac!

#### 5、堆和栈的区别

> 1.申请**方式**不同。
>
> 栈由**系统自动分配**。
>
> 堆是**自己申请和释放**的。
>
> 2.申请**大小限制**不同。
>
> **栈顶和栈底是之前预设**好的，栈是**向栈底扩展，大小固定**，可以通过ulimit -a查看，**由ulimit -s修改。**
>
> 堆**向高地址扩展**，是**不连续**的内存区域，**大小可以灵活调整**。
>
> 3.申请**效率**不同。
>
> 栈由**系统分配，速度快，不会有碎片**。
>
> 堆由**程序员分配，速度慢，且会有碎片**。
>
> 栈空间默认是4M, 堆区一般是 1G - 4G 

|              | 栈                                                           | 堆                                                           |
| ------------ | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 管理方式     | **栈中资源由编译器自动管理，无须手动控制**                   | **堆中资源由程序员控制**                                     |
| 内存管理机制 | 只要**栈的剩余空间大于所申请空<br/>间，系统为程序提供内存，否则报<br/>异常提示栈溢出。**（这一块理解一<br/>下链表和队列的区别，不连续空间<br/>和连续空间的区别，应该就比较好<br/>理解这两种机制的区别了） | 系统有一个**记录空闲内存地址的链表，当系统收到程序申<br/>请时，遍历该链表，寻找第一个空间大于申请空间的堆结<br/>点，删 除空闲结点链表中的该结点，并将该结点空间分配<br/>给程序**（大多数系统会在这块内存空间首地址记录本次分<br/>配的大小，这样delete才能正确释放本内存空间，另外系统<br/>会将多余的部分重新放入空闲链表中） |
| 空间大小     | 栈是一块**连续的内存区域**，**大小是<br/>操作系统预定好**的，windows下栈<br/>大小是2M（也有是1M，在 编译时<br/>确定，VC中可设置） | 堆是**不连续**的内存区域（因为系统是用链表来存储空闲内<br/>存地址，自然不是连续的），堆大小受限于计算机系统中<br/>有效的虚拟内存（32bit 系统理论上是4G），所以**堆的空间<br/>比较灵活，比较大** |
| 碎片问题     | 对于栈，它是有点**类似**于数据结构<br/>上的一个**先进后出的栈**，**进出一一<br/>对应，不会产生碎片**。（看到这里<br/>我突然明白了为什么面试官在问我<br/>堆和栈的区别之前先问了我栈和队<br/>列的区别） | **频繁的new/delete会造成大量碎片**                           |
| 生长方向     | **栈向下，向低地址方向增长。**                               | **堆向上，向高地址方向增长。**                               |
| 分配方式     | 栈有**静态分配和动态分配**，**静态分<br/>配由编译器完成**（如**局部变量**分<br/>配），**动态分配由alloca函数分<br/>配**，但栈的**动态分配的资源由编译<br/>器进行释放，无需程序员实现**。 | **堆都是动态分配（没有静态分配的堆）**                       |
| 分配效率     | 栈是其**系统提供的数据结构**，计算<br/>机在**底层对栈提供支持**，**分配专门<br/>寄存器存放栈地址，栈操作有专门<br/>指令。** | 堆由C/C++**函数库**提供，**机制很复杂。所以堆的效率比栈<br/>低很多。** |

**形象的比喻**

> 栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
>
> 
>
> 堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

#### 6、你觉得堆快一点还是栈快一点？

> 毫无疑问是栈快一点。
>
> 因为操作系统会在**底层对栈提供支持**，会分配**专门的寄存器存放栈的地址**，栈的**入栈出栈操作也十分简单**，并且有**专门的指令执行**，所以栈的**效率比较高也比较快**。
>
> 而堆的操作是由C/C++**函数库提供**的，在**分配堆内存**的时候需要一定的算法**寻找合适大小的内存**。并且**获取堆的内容需要两次访问**，**第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。**

#### 7、区别以下指针类型？

```cpp
int *p[10]//不强调指针，是一个存int型指针变量大小为10的数组
int (*p)[10]//pac：只有(*p)才是强调指针概念，p指向int型大小为0的数组
int *p(int)//p是带int类型参数的函数，函数返回值为int*类型
int (*p)(int)//pac：强调指针，p指向一个带有int类型参数的且返回值为int的函数
```

> int *p[10]表示**指针数组**，**强调数组**概念，是一个**数组变量**，**数组大小为10**，数组内**每个元素都是指向int类型的指针变量**。
>
> int (*p)[10]表示**数组指针**，**<u>强调是指针</u>**，只有**一个变量，是指针类型**，不过**指向的是一个int类型的数组，这个数组大小是10**。
>
> int *p(int)是**函数声明**，**函数名是p**，**参数是int**类型的，**返回值是int ***类型的。
>
> int (*p)(int)是**函数指针**，**<u>强调是指针</u>**，该**<u>指针指向的函数具有int类型参数，并且返回值是int类型的</u>**。

#### 8、new / delete 与 malloc / free的异同

> **相同点**
>
> <u>都可用于==内存的动态申请和释放==</u>
>
> **不同点**
>
> <u>前者是C++==运算符==，后者是C/C++语言==标准库函数==</u>
>
> <u>new自动计算</u>要分配的<u>空间大小</u>，<u>malloc需要手工计算</u>
>
> <u>new是类型安全</u>的，<u>malloc不是</u>。例如：
>
> ```cpp
> int *p = new float[2]; //编译错误
> 
> int *p = (int*)malloc(2 * sizeof(double));//编译无错误
> ```
>
> new调用名为**operator new**的==标准库函数分配====足够空间==并调用相关对象的构造函数，==delete==对指针所指对象==运行==适当的==析构函数==；然后通过==调用==名为**==operator delete==**的标准==库函数释放该对象所用内存==。
>
> 
>
> ==后者均没有相关调用==。
>
> ==后者需要库文件支持==，前者不用。
>
> ==new是封装了malloc，直接free不会报错==，但是这==只是释放内存，而不会析构对象==。

#### 9、new和delete是如何实现的？

> new的实现过程是：首先==调用==名为**operator ==new==**的标准==库函数==，==分配==足够大的原始为==类型化的====内存==，
>
> 以==保存==指定类型的一个==对象==；接下来==运行==该类型的一个==构造函数==，用==指定初始化构造对象==；最后返回
>
> ==指向新分配并构造后的的对象的指针==
>
> 
>
> delete的实现过程：对指针指向的对象==运行适当的析构函数==；然后通过==调用名为**operator delete**的标准库函数释放该对象所用内存==

#### 10、malloc和new的区别？

> malloc和free是==标准库函数，支持覆盖==；new和delete是==运算符，不重载==。
>
> 
>
> ==malloc仅仅分配内存空间，free仅仅回收空间==，==不==具备调用==构造函数==和==析构函数==功能，用malloc==分配空间====存储类的对象====存在风险==；new和delete==除了分配==回收功能外，还会==调用构造函数和析构函数。==
>
> 
>
> ==malloc和free返回的是void类型指针（必须进行类型转换）==，==new和delete返回的是具体类型指针。==

#### 11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

> malloc/free和new/delete都是用来申请内存和回收内存的。
>
> 
>
> 在==对非基本数据类型的对象使用==的时候，==对象创建的时候还需要执行构造函数==，==销毁的时候要执行析构函数==。而malloc/free是==库函数==，是==已经编译的代码==，所以不能把构造函数和析构函数的功能强加给malloc/free，所以==new/delete是必不可少的==。

#### 12、被free回收的内存是立即返还给操作系统吗？

> 不是的，被==free回收==的内存会==首先被ptmalloc使用双链表保存起来==，当用户==下一次申请内存==的时候，会尝试==从这些内存中寻找==合适的返回。这样就==避免了频繁的系统调用==，==占用过多的系统资源==。同时ptmalloc==也会尝试对小块内存进行合并==，==避免过多的内存碎片==。

#### 13、宏定义和函数有何区别？

> 宏在==编译时完成替换==，==之后被替换的文本参与编译==，相当于==直接插入了代码==，运行时==不存在函数调==
>
> ==用，执行起来更快==；
>
> 函数==调用在运行时需要跳转到具体调用函数==。==宏定义==属于在结构中插入代码，==没有返回值==；==函数调用具有返回值==。
>
> 
>
> ==宏定义参数没有类型，不进行类型检查==；
>
> ==函数参数具有类型，需要检查类型==。
>
> 
>
> ==宏定义不要在最后加分号==。

#### 14、宏定义和typedef区别？

> 宏==主要用于定义常量及书写复杂的内容==；typedef==主要用于定义类型别名==。
>
> 
>
> 宏替换发生在==编译阶段之前==，属于==文本插入替换==；typedef是编译的一部分。
>
> 
>
> 宏==不检查类型==；==typedef会检查数据类型==。
>
> 
>
> ==宏不是语句，不在在最后加分号==；==typedef是语句，要加分号标识结束==。
>
> 
>
> 注意==对指针的操作==，typedef char * p_char和#define p_char char *区别巨大。(pac:因为define是替换，他只能替换一个！！！)
>
> ```cpp
> typedef    (int*)   p1;
> p1 a, b;//代表 int * a, * b;
> ```
>
> 以及下面这行:
>
> ```
> #define    p2    int*
> p2 a, b;//代表 (int*) a,  b;因为define只能替换一次.
> ```
>
> 效果相同？实则不同！实践中见差别：
>
> **pINT a,b;的效果同int *a; int *b;**表示**定义了两个整型指针变量**。
>
> 而**pINT2 a,b;的效果同int *a, b;**表示**定义了一个整型指针变量a和整型变量b**

#### 15、变量声明和定义区别？

> ==声明仅仅==是把==变量的声明的位置及类型提供给编译器==，并==不分配内存空间==；==定义要在定义的地方为其==
>
> ==分配存储空间==。
>
> 相同变量可以在==多处声明（外部变量extern==），但只能在==一处定义。==

#### 16、strlen和sizeof区别？

> ==sizeof是运算符，并不是函数==，==结果在编译时得到而非运行中获得==；strlen是字符处理的==库函数。==
>
> ==sizeof参数==可以是==任何数据的类型或者数据==（sizeof参数不退化）；strlen的==参数只能是字符指针且结尾是'\0'的字符串==。
>
> 因为==sizeof值在编译时确定==，所以==不能==用来==得到动态分配（运行时分配）存储空间的大小==。

```cpp
int main(int argc, char const *argv[]){
 
 const char* str = "name";
 sizeof(str); // pac: 取的是指针  str的长度，是8
 strlen(str); // pac: 取的是这个字符串  的长度，不包含结尾的 \0。大小是4
 return 0;
 }
```

#### 17、常量指针和指针常量区别？

> ==指针常量==是一个指针，==读成常量的指针，指向一个只读变量==，也就是==后面所指明的int const 和 const int，都是一个常量==，可以写作==int const *p或const int *p==。
>
> 
>
> ==常量指针是一个不能给改变指向的指针==。==指针是个常量==，==必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了==，即不能中途改变指向，如==int *const p==。
>
> 
>
> 多说一句，网上关于指针常量和常量指针的说法很多跟书本上都不一致，甚至百度百科上跟《C++ Primer 5th》书上在指针常量和常量指针的说法刚好相反，鉴于百度百科是人人都可以去编辑，因此我信书。也希望各位遇到问题时要多去查阅资料，多去确认，不要因为某些博客或者文章说了就确认无疑。

#### 18、a和&a有什么区别？

> 假设数组int a[10]; int (*p)[10] = &a;其中：
>
> a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加
>
> 1操作后变为0x00000005。*(a + 1) = a[1]。
>
> &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首
>
> 地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
>
> 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

#### 19、C++和Python、Java、C的区别

> 1.包括但不限于：
>
> Python是一种==脚本语言，是解释执行==的，而C++是==编译语言，是需要编译后在特定平台运行==的。
>
> python可以很方便的==跨平台==，但是==效率没有C++高==。
>
> Python使用==缩进来区分不同的代码块==，C++==使用花括号==来区分
>
> C++中需要==事先定义变量的类型==，而==Python不需要==，Python的==基本数据类型只有数字，布尔值，字符串，列表，元组等等==
>
> Python的==库函数比C++的多，调用起来很方便==
>
> ```cpp
> int main(int argc, char const *argv[]){
> 
> 
> 
> const char* str = "name";
> 
> sizeof(str); // 取的是指针str的长度，是8
> 
> strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
> 
> return 0;
> 
> }
> ```
>
> 
>
> 2、C++和C语言的区别
>
> C++中==new和delete是对内存分配的运算符，取代了C中的malloc和free==。
>
> 标准C++中的==字符串类==取代了标准C函数库头文件中的==字符数组处理函数==（C中没有字符串类型）。
>
> C++中用来做控制态输入输出的==iostream类==库替代了标准C中的==stdio函数库==。
>
> C++中的==try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数==。
>
> 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别
>
> 开来。而这在C语言中是不允许的。也就是==C++可以重载，C语言不允许==。
>
> C++语言中，==允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以==；而C语言中，必
>
> 须要==在函数开头==部分。而且C++==允许重复定义变量==，==C语言也是做不到==这一点的
>
> 在C++中，除了值和指针之外，==新增了引用==。引用型变量是其他变量的一个别名，我们可以认为他们
>
> 只是名字不相同，其他都是相同的。
>
> C++相对与C==增加了一些关键字==，如：bool、using、dynamic_cast、namespace等等
>
> 
>
> #### 21、C++与Java的区别
>
> **语言特性**
>
> Java语言给开发人员提供了==更为简洁==的语法；==完全面向对象==，由于JVM可以安装到任何的操作系统
>
> 上，所以说它的==可移植性强==
>
> 
>
> Java语言中==没有指针==的概念，==引入了真正的数组==。==不同于C++中利用指针实现的“伪数组”==，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于==防止==在C++程序中常见的因为
>
> 数组操作越界等指针操作而对系统数据进行非法读写带来的==不安全问题==
>
> 
>
> C++也可以==在其他系统运行，但是需要不同的编码==（这一点==不如Java，只编写一次代码，到处运==
>
> ==行==），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成
>
> 字节码，在JVM里面运行得到结果
>
> 
>
> ==Java用接口(Interface)技术取代C++程序中的抽象类==。接口与抽象类有==同样的功能==，但是==省却了在实现和维护上的复杂性==
>
> 
>
> **垃圾回收**
>
> C++用==析构函数回收垃圾==，写C和C++程序时一定要==注意内存的申请和释放==
>
> Java语言不使用指针，==内存的分配和回收都是自动进行==的，程序员==无须考虑内存碎片==的问题
>
> 
>
> **应用场景**
>
> Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，==指针是c++的优势，可以直接对内存==
>
> ==的操作，但同时具有危险性== 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错
>
> 误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）
>
> 
>
> Java在Web 应用上具有C++ 无可比拟的优势，具有==丰富多样的框架==对于==底层程序的编程以及控制方面的编程==，==C++很灵活，因为有句柄的存在== 
>
> > 句柄：Windows系统中有许多内核对象（这里的对象不完全等价于"面向对象程序设计"一词中的"对象"，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个"对象"的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：
> >
> > 1. 暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；
> > 2. 操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？
> >
> > 所以，Windows操作系统就采用进一步的间接：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。
> >
> > 在Windows系统中，这个编号就叫做"句柄"。
> >
> > 
> >
> > ==我的理解==
> >
> > ==其实，句柄是一个指向指针的指针==。即：在*windows*程序设计中，句柄仅是一个应用程序用来识别某些事情的数字如果想更透彻一点地认识句柄，我可以告诉大家，句柄是一种指向指针的指针。我们知 道，所谓==指针是一种内存地址==。应用==程序启动后，组成这个程序的各对象是住留在内存的== 。如果简单地理解，似乎我们==只要获知这个内存的首地址==，那么就可以==随时用这个地址访问对象==。==但是==，如果您真的这样认为，那么您就大错特错了。我们知道，*Windows*是一个==以虚拟内存为基础==的操作系统。在这种系统环境下，*Windows*==内存管理器经常在内存中来回移动对象==，依此来==满足各种应用程序的内存需要==。==对象被移动意味着它的地址变化 了。如果地址总是如此变化，我们该到哪里去找该对象呢==*?为了解决这个问题，*Windows*操作系统为各应用程序==腾出一些内存储地址==，用来专门 ==登记各应用对象在内存中的地址变化==，而这个==地址*(*存储单元的位置*)*本身是不变的==。*Windows*内存管理器在==移动对象在内存中的位置后==，把对象==新的地址告知这个句柄地址来保存==。这样我们==只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置==。这个==地址是在对象装载*(Load)*时由系统分配给的，当系统卸载时*(Unload)*又释放给系统== 。
> >
> > 
> >
> > ==句柄地址*(*稳定*)→*记载着对象在内存中的地址*→*对象在内存中的地址*(*不稳定*) →*实际对象==但是，必须注意的是==程序每次从新启动==，系统==不能保证分配给这个程序的句柄还是原来的那个句柄==，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。
> >
> > 
> >
> > https://blog.csdn.net/XJF199001/article/details/45955353?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-45955353-blog-78198831.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-45955353-blog-78198831.pc_relevant_default&utm_relevant_index=1

#### 22、C++中struct和class的区别

> **相同点**
>
> 两者==都拥有成员函数、公有和私有部分==
>
> 任何==可以使用class完成的工作，同样可以使用struct完成==
>
> 
>
> **不同点**
>
> 两者中如果==不对成员不指定公私有==，==struct默认是公有==的，==class则默认是私有==的
>
> class默认是private继承，而struct模式是public继承
>
> 
>
> 引申：C++和C的struct区别
>
> ==C==语言中：==struct是用户自定义数据类型==（UDT）；==C++中struct是抽象数据类型==（ADT），==支持成员函数的定义，（C++中的struct能继承，能实现多态）==
>
> 
>
> ==C中struct是没有权限==的设置的，且struct中==只能是一些变量的集合体==，==可以封装数据却不可以隐藏数据，而且成员**不可以是函数**==
>
> 
>
> C++中，==struct增加了访问权限==，==且可以和类一样有成员函数==，==成员默认访问说明符为public（为了与C兼容）==
>
> 
>
> struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在==C中必须在结构标记前加==
>
> ==上struct，才能做结构类型名==（除：typedef struct class{};）;
>
> C++中==结构体标记（结构体名）可以直接作为结构体类型名使用==，此外==结构体struct在C++中被当作类的一种特例==

#### 23、define宏定义和const的区别

> **编译阶段**
>
> ==define是在编译的**预处理**阶段==起作用，而==const是在编译、运行的时候起==作用
>
> **安全性**
>
> ==define只做替换，不做类型检查和计算，也不求解，容易产生错误==，一般最好加上一个大括号包含住
>
> 全部的内容，要不然很容易出错
>
> ==const常量有数据类型，编译器可以对其进行类型安全检查==
>
> **内存占用**
>
> define只是==将宏名称进行替换，在内存中会产生多分相同的备份==。
>
> ==const==在程序==运行中只有一份备份，==且可以==执行常量折叠==，==能将复杂的的表达式计算出结果放入常量表。==
>
> 
>
> 宏替换发生在==编译阶段之前==，属于==文本插入替换==；const作用发生于==编译过程中==。
>
> 
>
> 宏定义的数据==没有分配内存==空间，只是插入替换掉；==const定义的变量只是值不能改变，但要分配内存空间。==

#### 24、C++中const和static的作用(待看)

> **static**
>
> 
>
> 不考虑类的情况
>
> 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能
>
> 在该文件所在的编译模块中使用
>
> 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
>
> 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量
>
> 相同，函数退出后仍然存在，但不能使用
>
> 
>
> 考虑类的情况
>
> static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，
>
> 必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
>
> static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const**、虚函数和volatile**；可以被非static成员函数任意访问。
>
> 
>
> **const**
>
> 不考虑类的情况
>
> 
>
> const常量在定义时必须初始化，之后无法更改
>
> const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const 
>
> int& i){ //...}
>
> 
>
> 考虑类的情况
>
> const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须
>
> 有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
>
> const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非
>
> mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

#### 25、C++的顶层const和底层const

==**顶层**const==：指的是const修饰的==**变量本身**==是一个==常量==，无法修改，指的是==指针，就是 * 号的右边==

==**底层**const==：指的是const修饰的==**变量所指向的对象**==是一个常量，指的是==所指变量==，就是 ==* 号的左边==

**举个例子**

```cpp
int a = 10;
int* const b1 = &a; //顶层const，b1本身是一个常量
const int* b2 = &a; //底层const，b2本身可变，所指的对象是常量
const int b3 = 20; //顶层const，b3是常量不可变
const int* const b4 = &a; //前一个const为底层，后一个为顶层，b4不可变

const int& b5 = a; //pac是底层不是顶层:用于声明引用变量，都是底层const
```

**区分作用**

> 执行==对象拷贝时有限制==，常量的==底层const不能赋值给非常量的底层const==
>
> 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const
>
> ```cpp
> const int a;int const a;const int *a;int *const a;
> ```
>
> int const a和const int a均表示定义常量类型a。
>
> const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
>
> int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

#### 26、数组名和指针（这里为指向数组首元素的指针）区别？

> 二者==均可通过增减偏移量来访问数组中的元素==。
>
> 
>
> ==数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作==。
>
> 
>
> **当==数组名当做形参传递给调用函数==后，就==失去了原有特性，退化成一般指针，多了自增、自减操作==，**
>
> ==但sizeof运算符不能再得到原数组的大小==了。//pac

#### 27、final和override关键字

**override**

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```cpp
class A 
{
 virtual void foo();
}

class B : public A 
{
 void foo(); //OK
 virtual void foo(); // OK
 void foo() override; //OK
}
```

> 如果不使用override，当你手一抖，将**foo()**写成了**f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器不会编译通过的：

```cpp
class A {
 virtual void foo();
};
class B : public A {
 virtual void f00(); //OK，这个函数是B新增的，不是继承的
 virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找
不到就报错
};
```

**final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：

```cpp
class Base
{
 virtual void foo();
};
class A : public Base
{
 void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写
};
class B final : A // 指明B是不可以被继承的
{
 void foo() override; // Error: 在A中已经被final了
};
class C : B // Error: B is final
{
};
```

#### 28、拷贝初始化和直接初始化

> //拷贝：<u>用指定构造函数创建临时对象，调用拷贝函数临时对象拷贝到创建对象。</u>
>
> //直接：<u>直接调用实参匹配的构造函数。</u>
>
> 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：==直接初始化直接调用与实参匹配的构造函数==，==拷贝初始化总是调用拷贝构造函数==。拷贝初始化首先使用==指定构造函数创建一个临时对象==，然后用==拷贝构造函数==将那个==临时对象拷贝到正在创建的对象==。举例如下:

```cpp
//括号内是直接初始化
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化

//括号外是拷贝初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

> **==为了提高效率，允许编译器跳过创建临时对象==这一步，**直接调用构造函数构造要创建的对象，这样就完全等价于**直接初始化了**（语句==1和语句3等价==），但是需要辨别两种情况。
>
> 
>
> 当==拷贝构造函数为private时：语句3和语句4在编译时会报错==。//pac
>
> 
>
> 使用==explicit修饰构造函数==时：如果==构造函数存在隐式转换，编译时会报错==。//pac

#### 29、初始化和赋值的区别

> 对于简单类型来说，初始化和赋值没什么区别对于类和复杂数据类型来说，这两者的区别就大了，举例如下：
>
> https://www.cnblogs.com/lxy-xf/p/11049963.html
>
> 关于构造函数，前面有两篇随笔写了==默认构造函数和拷贝构造函数==，其实还包括参数为一些成员变量属性的构造函数，现在自己理一下，这两个东西，他们只是参数不同，也就是说只是使用他们的方式不同。==默认构造函数是不传参==，构建的对象默认的使用那些值赋值给成员变量；而==拷贝构造==函数是接受一个相同类的另一个==临时对象==，使用该==临时对象来成员的为自己的成员赋值==；其他的一些构造函数也是如此，他们只是走的路线不同，==**最终目的都是为构建的一个对象进行初始化。**也就是说，构造函数的目的，是服务于类的初始化的，它并不服务于赋值。赋值是独立于初始化之后的操作。==

```cpp
class A{
public:
 int num1;
 int num2;
public:
 A(int a=0, int b=0):num1(a),num2(b){};
 A(const A& a){};
 //重载 = 号操作符函数
 A& operator=(const A& a){
 num1 = a.num1 + 1;
 num2 = a.num2 + 1;
 return *this;
 };
};
int main(){
 A a(1,1);
 A a1 = a; //拷贝初始化操作，调用拷贝构造函数
 A b;
 b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
 return 0; }
```

> 并不像我们想象的那样a1为(2,2),b也为(2,2)。这正是初始化与赋值的区别。
>
> 
>
> 在p1中，==A a1 = a;==这个操作中，实际上是通过一种==类似于拷贝构造函数中逐member的方式（但并没有生成一个拷贝构造函数==，生成拷贝构造函数的四种情况见34的随笔），==pac:并没有调用重载的"="运算符==。所以最终结果是a1为(1,1)。
>
> 而在p2中，==初始化与赋值是分开的==，==A b;就已经完成了初始化==，这个==初始化是通过定义的含参构造函数（但是以a=0,b=0的默认值完成的）==。
>
> ==然后再调用重载运算符==，对==p中成员均自加后赋值给p2的成员变量==。

#### 30、extern"C"的用法

> 为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
>
> 哪些情况下使用extern "C"： 
>
> （1）C++代码中调用C语言代码；
>
> （2）在C++中的头文件中使用；
>
> （3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；
>
> 举个例子，C++中调用C代码：

```cpp
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__
extern "C"{
 typedef unsigned int result_t;
 typedef void* my_handle_t;
 
 my_handle_t create_handle(const char* name);
 result_t operate_on_handle(my_handle_t handle);
 void close_handle(my_handle_t handle);
}
```

> 综上，总结出使用方法**，在****C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持
>
> **extern "C"****声明，在.c文件中包含了extern "C"时会出现编译语法错误。所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。
>
> 总结出如下形式：
>
> （1）C++调用C函数：
>
> ```cpp
> //xx.h
> extern int add(...)
> //xx.c
> int add(){
> }
> //xx.cpp
> extern "C" {
>  \#include "xx.h"
> }
> ```
>
> （2）C调用C++函数
>
> ```cpp
> //xx.h
> extern "C"{
>  int add();
> }
> //xx.cpp
> int add(){ 
> }
> //xx.c
> extern int add();
> ```

#### 31、野指针和悬空指针

>  ==都是是指向无效内存区域==(这里的无效指的是"==不安全不可控==")的指针，访问行为将会==导致未定义行为。==
>
> ==野指针，指的是没有被初始化过==的指针。因此，为了防止出错，对于指针初始化时都是赋值为nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。

```cpp
int main(void) { 
  int* p; // 未初始化
 std::cout<< *p << std::endl; // 未初始化就被使用
  return 0; }
```

> 悬空指针，指针最初指向的内存已经被释放了的一种指针。

```cpp
int main(void) { 
 int * p = nullptr;
 int* p2 = new int;
  p = p2;
 delete p2; }
```

> 此时 p和p2就是==悬空指针，指向的内存已经被释放==。继续使用这==两个指针，行为不可预料==。需要设置为p=p2=nullptr。此时再使用，编译器会直接保错。
>
> ==避免野指针比较简单，但悬空指针比较麻烦==。c++引入了==智能指针，//pac:C++智能指针的本质就是避免悬空指针的产生。==

> **产生原因及解决办法：**
>
> ==野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空==。
>
> ==悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空==。

#### 32、C和C++的类型安全

##### 1、什么是类型安全？

==类型安全很大程度上可以等价于内存安全==，类型安全的代码==不会试图访问自己没被授权的内存区域==。“类型安全”==常被用来形容编程语言==，其根据在于该门编程语言是否提供保障类型安全的机制；==有的时候也用“类型安全”形容某个程序==，判别的标准==在于该程序是否隐含类型错误==。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。

##### 2、C的类型安全

C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：

printf格式输出![image-20220819133210211](E:\笔记\图片库\image-20220819133210211.png)

上述代码中，使用==%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误==

malloc函数的返回值

==malloc==是C中进行内存分配的函数，它的==返回类型是void*即空类型指针==，常常有这样的用法==char * pStr=====(char* )malloc(100 * sizeof(char))==，这里明显做了显式的类型转换。

==类型匹配尚且没有问题==，但是一旦出现==int* pInt===  ==(int* )malloc(100*sizeof(char))==就很可能带来一些问题，而这样的转换C并==不会提示错误==。

##### 3、C++的类型安全

如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安

全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*

- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；

- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换

- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全

- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

例1：使用void*进行类型转换

![image-20220819134936084](E:\笔记\图片库\image-20220819134936084.png)

例2：不同类型指针之间转换

```cpp
#include<iostream>
using namespace std;
class Parent{};
class Child1 : public Parent
{
public:
 int i;
 Child1(int e):i(e){}
};
class Child2 : public Parent
    {
public:
 double d;
 Child2(double e):d(e){}
};
int main()
{
 Child1 c1(5);
 Child2 c2(4.1);
 Parent* pp;
 Child1* pc1;
 
 pp=&c1; 
 pc1=(Child1*)pp; // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误
 cout<<pc1->i<<endl; //输出：5
 pp=&c2;
 pc1=(Child1*)pp; //强制转换，且类型发生变化，将造成错误
 cout<<pc1->i<<endl;// 输出：1717986918
 return 0; }
```

> 上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void* ，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应==尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。==

#### 33、C++中的重载(overload)、重写（覆盖override）和隐藏(hide)的区别

##### 1、重载（overload）

重载是指在==同一范围定义中的**同名成员函数**才存在重载关系==。主要特点是==函数名相同==，==参数类型和数目有所不同==，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```cpp
class A{
 ...
 virtual int fun();
 void fun(int);
 void fun(double, double);
 static int fun(char);
 ...
}
```

##### 2、重写(覆盖)(override)

> 重写指的是在派生类中覆盖基类中的==同名函数==，**重写就是重写函数体**，**要求基类函数必须是虚函数**且：
>
> - 与基类的虚函数有==相同的参数个数==
>
> - 与基类的虚函数有==相同的参数类型==
>
> - 与基类的虚函数有==相同的返回值类型==
>
> 举个例子:

```cpp
//父类
class A{
public:
 virtual int fun(int a){}
}
//子类
class B : public A{
public:
 //重写,一般加override可以确保是重写父类的函数
 virtual int fun(int a) override{}
}
```

> 重载与重写的区别：
>
> - 重写是==父类和子类之间的垂直关系==，重载是==不同函数之间的水平关系==
>
> - 重写要求==参数列表相同==，重载则要求==参数列表不同，返回值不要求==
>
> - 重写关系中，==调用方法==根据==对象类型决定==，重载根据调用时==实参表与形参表的对应关系==来选择函数体

##### 3、隐藏（hide）

隐藏指的是某些情况下，==派生类中的函数屏蔽了基类中的同名函数==，包括以下情况：

1.两个函数==参数相同，但是基类函数不是虚函数==。和==重写==的区别在于==基类函数是否是虚函数==。举个例子：

```cpp
//父类
class A{
public:
 void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
public:
 //隐藏父类的fun函数
 void fun(int a){
 cout << "B中的fun函数" << endl;
 }
};
int main(){
 B b;
 b.fun(2); //调用的是B中的fun函数
 b.A::fun(2); //调用A中fun函数
 return 0; }
```

2.两个函数==参数不同==**，**无论==基类函数是不是虚函数**，**都会被隐藏==**。**和==重载==的区别在于==两个函数不在同一个类中==。举个例子：

```cpp
//父类
class A{
public:
 virtual void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
    public:
 //隐藏父类的fun函数
 virtual void fun(char* a){
 cout << "A中的fun函数" << endl;
 }
};
int main(){
 B b;
 b.fun(2); //报错，调用的是B中的fun函数，参数类型不对
 b.A::fun(2); //调用A中fun函数
 return 0; }
```

#### 34、C++有哪几种的构造函数

> C++中的构造函数可以分为4类：
>
> - ==默认构造==函数（没有参数，赋值为什么，看结构体内部写的是什么）
>
> - ==初始化构造==函数（有参数）
>
> - ==拷贝构造==函数
>
> - 移动构造函数（move和右值引用）//pac
>
> - 委托构造函数
>
> - ==转换构造==函数
>
> 举个例子：

```cpp
#include <iostream>
using namespace std;
class Student{
public:
 Student(){//默认构造函数，没有参数
 this->age = 20;
 this->num = 1000;
 }; 
 Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
 Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
 this->age = s.age;
 this->num = s.num;
 }; 
 Student(int r){ //转换构造函数,形参是其他类型变量，且只有一个形参
 this->age = r;
 this->num = 1002;
 };
 ~Student(){}
public:
 int age;
 int num;
};
int main(){
 Student s1;//默认构造
 Student s2(18,1001);//初始化构造
 int a = 10;
 Student s3(a);//转移构造
 Student s4(s3);//拷贝构造
 printf("s1 age:%d, num:%d\n", s1.age, s1.num);
 printf("s2 age:%d, num:%d\n", s2.age, s2.num);
 printf("s3 age:%d, num:%d\n", s3.age, s3.num);
 printf("s2 age:%d, num:%d\n", s4.age, s4.num);
 return 0; }
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002
```

> 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
>
> 复制构造函数用于复制本类的对象
>
> 转换构造函数用于将其他类型的变量，隐式转换为本类对象

> https://blog.csdn.net/zxc024000/article/details/51153743
>
> 转换构造函数可以用在哪里？
> 假如重载了+号运算符，使得两个Student类的对象可以相加，其结果为两个对象的成员变量age之和。
>
> ```cpp
> Student s1(01,18);
> Student s2(02,20);
> s1+s2;  //其值就是s1.age + s2.age = 18+20=36。
> ```
>
> **那么 s1+19 呢(类对象与int直接相加）？ **
> 因为我们定义了 转换构造函数，那么 s1+19，执行如果过程：
> 首选调用+号运算符，发现19不是Student类的对象，而是int类型然后调用转换构造函数，将19变为Student（19）现在便可以进行加法运算，其值是s1.age+ (TempStudentObject).age=18+19 = 37

#### 35、浅拷贝和深拷贝的区别

##### 1、浅拷贝

name = s.name;

浅拷贝==只是拷贝一个指针，并没有新开辟一个地址==，拷贝的指针==和原来的指针指向同一块地址==，如果==原来的指针所指向的资源释放==了，那么==再释放浅拷贝的指针的资源就会出现错误==。

##### 2、深拷贝

name = new char(20); memcpy(name, s.name, strlen(s.name));

深拷贝==不仅拷贝值==，还开辟出一块==新的空间用来存放新的值==，即使==原先的对象被析构掉==，释放内存了==也不会影响到深拷贝得到的值==。在自己实现==拷贝赋值==的时候，如果==pac:有指针变量的话是需要自己实现深拷贝的。==

```cpp
#include <iostream> 
#include <string.h>
using namespace std;
class Student
{
private:
 int num;
 char *name;
public:
 Student(){
 name = new char(20);
 cout << "Student" << endl;
 };
 ~Student(){
 cout << "~Student " << &name << endl;
 delete name;
 name = NULL;
 };
 Student(const Student &s){//拷贝构造函数
 //浅拷贝，当对象的name和传入对象的name指向相同的地址
 name = s.name;
 //深拷贝
 //name = new char(20);
 //memcpy(name, s.name, strlen(s.name));
 cout << "copy Student" << endl;
 };
};
int main()
{
 {// 花括号让s1和s2变成局部对象，方便测试
Student s1;
 Student s2(s1);// 复制对象
 }
 system("pause");
 return 0; }
//浅拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffed0c3ec0
//~Student 0x7fffed0c3ed0
//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 
0x0000000001c82c20 ***
//深拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffebca9fb0
//~Student 0x7fffebca9fc0
```

#### 36、内联函数和宏定义的区别

> [参考1](https://blog.csdn.net/jiechuhoudeshang/article/details/90299466?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90299466-blog-48712453.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90299466-blog-48712453.pc_relevant_default&utm_relevant_index=1)
>
> [参考2](https://blog.csdn.net/will130/article/details/48712453)

> - 在使用时，宏只做==简单字符串替换（编译前==）。而内联函数可以==进行参数类型检查（编译时==），且==具有返回值==。
>
> - 内联函数在==编译时直接将函数代码嵌入到目标代码==中，==省去函数调用==的开销来提高执行效率，并且==进行参数类型检查==，==具有返回值，可以实现重载==。
>
> - 宏定义时要注意书写（参数要括起来）否则容易==出现歧义==，内联函数==不会产生歧义==
>
> - 内联函数有==类型检测、语法判断==等功能，而宏没有。
>
> 内联函数适用场景:
>
> 使用==宏定义的地方都可以使用 inline 函数==。
>
> 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。

> 1.内联函数在运行时==可调试==，而==宏定义不可以==;
> 2.编译器会对内联函数的==参数类型做安全检查或自动类型转换==（同普通函数），而宏定义则不会； 
> 3.内联函数可以==访问类的成员变量==，宏定义则不能； 
> 4.在类中声明同时定义的成员函数，自动转化为内联函数。
>
> 内联函数和普通函数相比可以**==加快程序运行的速度==**，因为不需要[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)调用，在**编译**的时候内联函数可以**直接被镶嵌到目标代码**中。
>
> 内联函数要做**参数类型检查**，这是内联函数跟宏相比的优势。
>
> inline是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。**对于短小的代码来说，inline可以带来一定的效率提升**，而且和C时代的宏函数相比，inline **更安全可靠**。可是这个是以**==增加空间消耗为代价==**的。至于是否需要inline函数就需要根据你的实际情况取舍了。
>
> inline一般只用于如下情况：
>
> > （1）一个函数==不断被重复调用==。
> >
> > （2）函数==只有简单的几行，且函数不包含for、while、switch语句==。
>
> 宏在C语言里极其重要，而在C++里用得就少多了。关于宏的第一规则是：绝不应该去使用它，除非你不得不这样做。几乎每个宏都表明了程序设计语言里或者程序里或者程序员的一个缺陷，因为它将在编译器看到程序的正文之前重新摆布这些正文。宏也许是许多程序设计工具的麻烦。所以，如果你使用了宏，你就应该准备着只能从各种工具（如排错系统、交叉引用系统、轮廓程序等）中得到较少的服务。
>
> **宏是在代码处不加任何验证的简单替代，而==内联函数是将代码直接插入调用处==，而==减少了普通函数调用时的资源消耗==。**
>
> **宏不是函数，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体**。
>
> **==inline函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处==。**
>
> ```cpp
> inline fact(float i) { return i * i; } // 没有写返回值的
> printf("bb= %d", fact(8)); // 调用时就是执行printf("bb= %d", 8*8);
> ```
>
> 关于类的例子如下：
>
> ```cpp
> Class A
> {
> public：
>     int readTest（）
>     {
>         return nTest；
>     }
>     void setTest（int i);
> };
> inline void A::setTest(int i)
> {
>     nTest=i;
> };
> ```
>
> **类A的成员函数readTest（）和setTest（）都是内联函数，readTest（）函数的定义体被放在类声明之中，因而readTest（）自动转换成inline函数，setTest函数的定义体在类声明之外，因此要加上inline关键字。**

> 1.宏定义：本例子需要注意括号的使用，不然歧义。并且本例宏定义实现是错误的。
>
> `#define MAX(a，b) ((a)>(b)?(a):(b))`
> ``MAX(a,"Hello")；`` //==错误地比较int和字符串，没有参数类型检查==
>
> 
>
> 2.内联函数：
>
> ```cpp
> #include <stdio.h>
> 
> inline int add(int a, int b)
> {
>     return (a + b);//pac
> }
> 
> int main(void)
> {
>     int a;
> 
> a = add(1, 2);//pac
> printf("a+b=%d\n", a);
> 
> return 0;
> 
> }
> ```
>
> ==以上a = add(1, 2);处在编译时将被展开为：a = (a + b);==
>
> 
>
> 3、使用时的一些注意事项：
>
> - 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
>
> - inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
> - 同其它函数不同的是，==最好将inline函数定义在头文件==，而不仅仅是声明，因为编译器在处理inline函数时，==需要在调用点内联展开该函数==，所以==仅需要函数声明是不够的==。
>
> 4、内联函数使用的条件：
>
> 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况==不宜使用内联==： 
> （1）如果函数体内的==代码比较长，使用内联将导致内存消耗代价较高==。 
> （2）如果函数体内出现==循环，那么执行函数体内代码的时间要比函数调用的开销大==。 
> 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。
>
> 
>
> 5、使用内联函数和宏函数可能带来的问题（慎用）：
>
> 有时不要仅是为了提高编程效率而使用这两种函数，要综合考虑后再使用，因为有时使用这两种函数可能带来其他的问题，比如出现问题不能使用gdb调试问题，内联函数不展开，宏函数没有参数检测等

#### 37、public，protected和private访问和继承权限/public/protected/private的区别？

> - ==public的变量和函数==在==类的内部外部==都可以访问。
>
> - ==protected==的变量和函数只能在==类的内部和其派生类==中访问。
>
> - ==private修饰的元素只能在类内访问==。

##### 1、访问权限

> 派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意==外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问==。

![image-20220819181103344](E:\笔记\图片库\image-20220819181103344.png)

> 派生类对基类成员的访问形象有如下两种：
>
> ==内部==访问：由==派生类中新增的成员函数对从基类继承来的成员的访问==
>
> **==外部==访问**：在==派生类外部，通过派生类的对象对从基类继承来的成员的访问==

##### 2、继承权限

> 1.public继承
>
> ==公有继承==的特点是基类的==公有成员和保护成员==作为派生类的成员时，都==保持原有==的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问

> 2.protected继承
>
> ==保护继承==的特点是基类的所有==公有成员和保护成员==都成为派生类的==保护成员==，并且==只能被它的派生类成员函数或友元函数访问==，基类的私有成员仍然是私有的，访问规则如下表。

![image-20220819181139327](E:\笔记\图片库\image-20220819181139327.png)

> 3.private继承
>
> ==私有继承==的特点是基类的所有==公有成员和保护==成员都成为派生类的==私有成员==，==并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承==，访问规则如下表

![image-20220819181150528](E:\笔记\图片库\image-20220819181150528.png)

#### 38、如何用代码判断大小端存储？

> ==Little==-Endian：==低位字节==排放在内存的==低地址端==，高位字节排放在内存的高地址端。
> ==Big-==Endian：==高位字节==排放在内存的==低地址端==，低位字节排放在内存的高地址端。
>
> 一般操作系统都是小端，而通讯协议是大端的。
>
> ###### 4.1 常见CPU的字节序
>
> Big Endian : PowerPC、IBM、Sun
> Little Endian : x86、DEC
> ARM既可以工作在大端模式，也可以工作在小端模式。
>
> 
>
> C51是大端存储；==Java==、==socket编程中网络字节序一般是大端存储==
>
> ==x86结构、DSP都是小端存储==。
>
> 
>
> 比如0x12345678在内存中的表示形式为：
> 采用大端模式：
> 低地址 --------------------> 高地址
> 0x12(==高位字节==) | 0x34 | 0x56 | 0x78(==低位字节==)
> 采用小端模式：
> 低地址 --------------------> 高地址
> 0x78 | 0x56 | 0x34 | 0x12
>
> 
>
> 大端存储：字数据的高字节存储在低地址中
>
> 小端存储：字数据的低字节存储在低地址中
>
> 例如：32bit的数字0x12345678
>
> 所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址==转换为大端存储，这样才能进行网络传输==
>
> \#define ntohs(n)   //16位数据类型网络字节顺序到主机字节顺序的转换
>
> \#define htons(n)   //16位数据类型主机字节顺序到网络字节顺序的转换
>
> \#define ntohl(n)   //32位数据类型网络字节顺序到主机字节顺序的转换
>
> \#define htonl(n)   //32位数据类型主机字节顺序到网络字节顺序的转换
>
> 



小端模式中的存储方式为：

![image-20220819183232766](E:\笔记\图片库\image-20220819183232766.png)

大端模式中的存储方式为：

![image-20220819183249057](E:\笔记\图片库\image-20220819183249057.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

方式一：使用强制类型转换

```cpp
#include <iostream>
using namespace std;
int main(){
    int a = 0x01234567;
    char b =  (char) a; //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    //char b = * (char *) &a;
    if(b == 0x67) cout<<"Little";
    else cout<<"Big";
}
```

方式二：巧用union联合体

```cpp
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
 int a;
 char ch;
};
int main()
{
 endian value;
 value.a = 0x1234;
 //a和ch共用4字节的内存空间
 if (value.ch == 0x12)
 cout << "big endian"<<endl;
 else if (value.ch == 0x34)
 cout << "little endian"<<endl; }
```

```cpp
int main(){
    union t{//共用类型foo,占用最大类型长度的整数倍(double ,8字节)，union大小为8字节。
        double i ;//double 为8字节，所以为8*2 = 16即可满足。
        char s[10];
    };
    cout<<sizeof(t);
}
--------
Outputs: 16
如果int i；那么sizeof t == 12.
```

```cpp
union foo{//最大类型长度的整数倍，并且要能容纳char
    int i;//int 4字节，所以t大小为4 * 3 =12
    char s[10];
}
OUtputs:
12
```

> **1.共用体声明和共用体变量定义**
>
> [共用体](https://baike.baidu.com/item/共用体)(参考“共用体”百科词条)是一种特殊形式的变量，使用[关键字](https://baike.baidu.com/item/关键字)union来定义
>
> 共用体(有些人也叫"联合")声明和共用体变量定义与[结构体](https://baike.baidu.com/item/结构体)十分相似。其形式为:
>
> union 共用体名{
>
> 数据类型 成员名;
>
> 数据类型 成员名;
>
> ...
>
> } 变量名;
>
> 
>
> ==共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量。在union中，所有的共用体成员共用一个空间，并且同一时间只能储存其中一个[成员变量](https://baike.baidu.com/item/成员变量)的值==。
>
> 在共用体变量bar中, 整型变量i和字符变量c==共用同一内存位置==。
> 当一个共用体被声明时, 编译程序自动地产生一个变量, 其==长度为联合中类型字节数最多的变量的类型长度的整数倍==。以上例而言，最大长度是double数据类型，所以foo的内存空间就是double型的长度。
>
> **2. 共用体和结构体的区别**
>
> [共用体](https://baike.baidu.com/item/共用体)和结构体有下列区别:
>
> 1. ==共用体和[结构体](https://baike.baidu.com/item/结构体)都是由多个不同的数据类型成员组成==, 但在任何==同一时刻==, ==共用体只存放了一个被选中的成员==, 而==结构体的所有成员都存在==。
>
> 2. 对于==共用体的不同成员赋值, 将会对其它成员重写==, 原来成员的值就不存在了, 而对于==结构体的不同成员赋值是互不影响的。==

