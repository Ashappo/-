

[TOC]

#### 1、在main执行之前和之后执行的代码可能是什么？

> **main****函数执行之前**，主要就是<u>初始化系统相关资源</u>**：
>
> - ==**<u>设置栈指针</u>**==
>
> - <u>==初始化**静态static变量**和**global全局变量**，即.**data段的内容==**</u>
>
> - 将<u>**==未初始化部分的全局变量赋初值==**</u>：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即<u>**==.bss段的内容==**</u> 
>
>
> - <u>**==全局对象初始化==**，在main之前**==调用构造函数==**</u>，这是可能会执行前的一些代码<u>将**==main函数的参数argc，argv等传递给main函数==**</u>，然后才真正运行main函数
>
> - <u>__attribute__((constructor))</u>
>
> 
>
> **main****函数执行之后**： 
>
> - **==全局对象的析构函数会在main函数之后执行==**；//pac
>
> - 可以用 **atexit** 注册一个函数，它会在main 之后执行;//pac
>
>
> - __attribute__((destructor))

#### 2、结构体内存对齐问题？

> https://cloud.tencent.com/developer/article/1727794
>
> http://www.feihuo-tech.net:8090/pages/viewpage.action?pageId=30638624

##### **1、什么是内存对齐**

> 还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。
>

```cpp
//32位系统
#include<stdio.h>
struct{
int x;
char y;
}s;
int main()
{
printf("%d\n",sizeof(s);  // 输出8
return 0;
}
```

> 现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

##### 2、内存对齐的单位

> 通过上面的分析，知道内存对齐的目的是为了让CPU能一次获取到数据，从而提升性能。学过汇编会了解，CPU只能使用基本类型，char, short, int, long, float, double 等，不能使用数组或结构体等复合类型（汇编中并没有一个指令能直接存取一个struct或数组）。所以：内存对齐的单位是基本类型，目标是让CPU能一次获取到基本类型的值。
>

##### 3、内存对齐的原则

> **先让我们看四个重要的基本概念：**
>
> |                  | 32位 | 64位         |
> | ---------------- | ---- | ------------ |
> | char             | 1    | 1            |
> | short int(short) | 2    | 2            |
> | int              | 4    | 多数4，少数8 |
> | long int (long)  | 4    | 8            |
> | long long        | 8    | 8            |
> | float            | 4    | 4            |
> | double           | 8    | 8            |
> | 指针             | 4    | 8            |
>
> **1.==数据类型自身的对齐值==：**
> **对于char型数据，其自身对齐值为1，对于short型为2，对于int,float，其自身对齐值为4，单位字节。double类型8字节**
> **2.==结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值==。**
> **3.==指定对齐值==：==#pragma pack (value)时的指定对齐值value==。**
> **4.数据成员、结构体和类的==有效对齐值：自身对齐值和指定对齐值中小的那个值==。**
>
> 
>
> **struct/class/union内存对齐原则有四个：**
>
> 1).数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，**==pac:以后每个成员相对于结构体首地址的 offset <u>都是该成员大小与有效对齐值中较小那个的整数倍==</u>**，如有需要编译器会在成员之间加上填充字节。(比如int在３２位机为４字节,指定对齐值是2， 则要从2的整数倍地址开始存储，char 自身对齐值是 1，指定对齐值是2，则要从1的整数倍开始),基本类型不包struct/class/uinon。
>
> 2).收尾工作:==**结构体的总大小**为 有效对齐值 的**整数倍**==，如有需要编译器会在最末一个成员之后加上填充字节。(基本类型不包括struct/class/uinon)。
>
> 3).sizeof(union)，以结构里面size最大元素的整数倍为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。
>
> 下面给出几个例子以便于理解：
>
> ```cpp
> //32位系统
> #include<stdio.h>
> struct
> {
> int c1;    //自身对齐和有效对齐值较小的整数倍,所以c1:0-4存
> char c2;  //c2: 4-5存
> char c3;  //c3: 5-6，剩下6-8空闲补齐，共8字节
> }x1;
> struct{
> char c1;  //c1：0-1存,1-4空闲
> int c2;    //c2: 4 - 8存
> char c3;  //c3:8-9存, 9-12空闲，共12字节
> }x2;
> 
> struct{
> char c1;  //c1: 0-1存
> char c2; //c2:1-2存  2-4空闲
> int c3;   //c3:4-8存，共8字节
> }x3;
> 
> int main()
> {
> printf("%d\n",sizeof(x1));  // 输出8
> printf("%d\n",sizeof(x2));  // 输出12
> printf("%d\n",sizeof(x3));  // 输出8
> return 0;
> }
> ```
>
> 以上测试都是在Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节，下面根据上面所说的规则以s2来分析其内存布局：
>
> 首先使用规则1，对成员变量进行对齐：
>
> sizeof(c1) = 1 <= 4(有效对齐位)，按照1字节对齐，占用第0单元；
>
> sizeof(i) = 4 <= 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；
>
> sizeof(c2) = 1 <= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；
>
> 然后使用规则2，对结构体整体进行对齐：
>
> s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。
>

##### 4、#pragma pack(n)

> 不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数。
>
> 例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。
>
> 如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：
>
> 经过上面的实例分析，大家应该对内存对齐有了全面的认识和了解，在以后的编码中定义结构体时需要考虑成员变量定义的先后顺序了。

##### 5、内存对齐的作用

> 1、 **平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。**
>
> 
>
> **2、 性能原因：经过内存对齐后，CPU的内存访问速度大大提升**。具体原因稍后解释。
>
> 
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast.jpeg)
>
> 这是普通程序员心目中的内存印象，由一个个的字节组成，而CPU并不是这么看待的。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483481.jpeg)
>
> CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为memory access granularity（粒度） 本人把它翻译为“内存读取粒度” 。
>
> 假设CPU要读取一个int型4字节大小的数据到寄存器中，分两种情况讨论：
>
> 1、数据从0字节开始
>
> 2、数据从1字节开始
>
> 再次假设内存读取粒度为4。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483482.jpeg)
>
> 当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。
>
> 当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。
>
> ![这里写图片描述](E:\笔记\图片库\SouthEast-16608221483493.jpeg)
>
> 此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。
>
> 这还属于乐观情况了，上文提到内存对齐的作用之一为平台的移植原因，因为以上操作只有有部分CPU肯干，其他一部分CPU遇到未对齐边界就直接罢工了。

> sizeof(Info)求的是结构体元素的大小，而alignof(Info)求的是结构体有效对齐值
>
> 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
>
> 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）
>
> c++11以后引入两个关键字 alignas与 alignof。其中alignof可以计算出类型的对齐方式，alignas可以指
>
> 定结构体的对齐方式。
>
> 但是alignas在某些情况下是不能使用的，具体见下面的例子:
>
> ```cpp
> // alignas 生效的情况
> 
> struct Info {
> 
> uint8_t a;//同上，默认情况下：min(1,2) 0-1存，1-2空闲			alignof(4)情况下：min(1,4),0-1存，1-2空闲
> 
> uint16_t b;//min(2,4) 2-4存										    min(2,4),	2-4存，						
> uint8_t c;//4-5存，5-6空闲，共占6字节。			 min(1,4),4-5存，因为struct应该是(类中数据类型最大的对齐值与指定对齐值中较小值的整数倍)，5-8空闲，共占8字节
>     
> };
> 
> std::cout << sizeof(Info) << std::endl; // 6 2 + 2 + 2， uint8_t占用1字节，但是按照内存对齐按照默认最大的成员 uint16_t b;占用2字节，所以a也需要按照对齐，占用2字节，所以为2+2+2
> 
> std::cout << alignof(Info) << std::endl; // 2：求得内存对齐的大小：为uint16_t b;占用2字节：2
> 
> struct alignas(4) Info2 {//将默认对齐大小变为4，那么uint8_t a对应;+uint16_t b;加一起才3字节，都可以放到4字节中，
> //pac!!!每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍,那么uint8_t a占用0-1字节，uint16_t b起始地址是min(2,4) = 2所以占用 2-3字节.
> uint8_t a;//占用[0-1]中的0字节，
> 
> uint16_t b;//pac!!!首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍,所以占用2-3字节
> 
> uint8_t c;//而uint8_t c单独占用[4-7]中的4字节。所以ab一组占用4，后面c单独一组占用4 ：4+4
> 
> };
> 
> std::cout << sizeof(Info2) << std::endl; // 8 4 + 4
> 
> std::cout << alignof(Info2) << std::endl; // 4
> 
> alignas将内存对齐调整为4个字节。所以sizeof(Info2)的值变为了8。
> 
> 
> ```
>
> ```cpp
> // alignas 失效的情况
> 
> struct Info {
> 
> uint8_t a;
> 
> uint32_t b;
> 
> uint8_t c;
> 
> };
> 
> std::cout << sizeof(Info) << std::endl; // 12 4 + 4 + 4
> 
> std::cout << alignof(Info) << std::endl; // 4
> 
> struct alignas(2) Info2 {//指定小于最大，无效
> 
> uint8_t a;
> 
> uint32_t b;
> 
> uint8_t c;
> 
> };
> 
> std::cout << sizeof(Info2) << std::endl; // 12 4 + 4 + 4
> 
> std::cout << alignof(Info2) << std::endl; // 4
> ```
>
> 
>
> **==若alignas小于自然对齐的最小单位，则被忽略==。**
>
> 如果想使用单字节对齐的方式，使用alignas是无效的。应该使用#pragma pack(push,1)或者使用
>
> __attribute__((packed))。

```cpp
//#下面没太看懂为什么std::cout << alignof(Info) << std::endl; // 6
#if defined(__GNUC__) || defined(__GNUG__)
 #define ONEBYTE_ALIGN __attribute__((packed))
#elif defined(_MSC_VER)
 #define ONEBYTE_ALIGN
 #pragma pack(push,1)
#endif
struct Info {
 uint8_t a;
 uint32_t b;
 uint8_t c;
} ONEBYTE_ALIGN;
#if defined(__GNUC__) || defined(__GNUG__)
 #undef ONEBYTE_ALIGN
#elif defined(_MSC_VER)
 #pragma pack(pop)
 #undef ONEBYTE_ALIGN
#endif
std::cout << sizeof(Info) << std::endl; // 6 1 + 4 + 1
std::cout << alignof(Info) << std::endl; // 6
```

```cpp
//#下面没太看懂为什么std::cout << sizeof(Info) << std::endl; // 2
//std::cout << alignof(Info) << std::endl; // 1
确定结构体中每个元素大小可以通过下面这种方法:
这种处理方式是alignas处理不了的。
#if defined(__GNUC__) || defined(__GNUG__)
 #define ONEBYTE_ALIGN __attribute__((packed))
#elif defined(_MSC_VER)
 #define ONEBYTE_ALIGN
 #pragma pack(push,1)
#endif
/**
* 0 1 3 6 8 9 15
* +-+---+-----+---+-+-------------+
* | | | | | | |
* |a| b | c | d |e| pad |
* | | | | | | |
* +-+---+-----+---+-+-------------+
*/
struct Info {
 uint16_t a : 1;
 uint16_t b : 2;
 uint16_t c : 3;
 uint16_t d : 2;
 uint16_t e : 1;
 uint16_t pad : 7;
} ONEBYTE_ALIGN;
#if defined(__GNUC__) || defined(__GNUG__)
 #undef ONEBYTE_ALIGN
#elif defined(_MSC_VER)
 #pragma pack(pop)
 #undef ONEBYTE_ALIGN
#endif
std::cout << sizeof(Info) << std::endl; // 2
std::cout << alignof(Info) << std::endl; // 1
```

#### 3、指针和引用的区别

[指针和引用的区别](E:\笔记\c++\关键字和运算符.md)

> (1)指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
>
> (2)指针可以有多级，引用只有一级
>
> (3)指针可以为空，引用不能为NULL且在定义时必须初始化
>
> (4)指针在初始化后可以改变指向，而引用在初始化之后不可再改变
>
> (5)sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
>
> (6)当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
>
> (7)引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（具体情况还要具体分析）。
>
> (8)引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
>
> (9)引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
>
> 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
>
> ```cpp
>\#if defined(__GNUC__) || defined(__GNUG__)
> 
>\#define ONEBYTE_ALIGN __attribute__((packed))
> 
>\#elif defined(_MSC_VER)
> 
>\#define ONEBYTE_ALIGN
> 
> \#pragma pack(push,1)
> 
> \#endif
> 
> /**
> 
> \* 0 1 3 6 8 9 15
> 
> \* +-+---+-----+---+-+-------------+
> 
> \* | | | | | | |
> 
> \* |a| b | c | d |e| pad |
> 
> \* | | | | | | |
> 
> \* +-+---+-----+---+-+-------------+
> 
> */
> 
> struct Info {
> 
> uint16_t a : 1;//代表占用的
> 
> uint16_t b : 2;
> 
> uint16_t c : 3;
> 
> uint16_t d : 2;
> 
> uint16_t e : 1;
> 
> uint16_t pad : 7;
> 
> } ONEBYTE_ALIGN;
> 
> \#if defined(__GNUC__) || defined(__GNUG__)
> 
> \#undef ONEBYTE_ALIGN
> 
> \#elif defined(_MSC_VER)
> 
> \#pragma pack(pop)
> 
> \#undef ONEBYTE_ALIGN
> 
> \#endif
> 
> std::cout << sizeof(Info) << std::endl; // 2
> 
> std::cout << alignof(Info) << std::endl; // 1
> 
> **33**参考代码：
> 
> void test(int *p) 
> 
> {
> 
> int a=1;
> 
> p=&a;
> 
> cout<<p<<" "<<*p<<endl; 
> 
> }
> 
> 
> int main(void) 
> 
> {
> 
> int *p=NULL;
> 
> test(p);
> 
> if(p==NULL)
> 
> cout<<"指针p为NULL"<<endl;
> 
> return 0; 
> 
> }
> 
> 
> //运行结果为：
> 
> //0x22ff44 1
> 
> //指针p为NULL
> 
> void testPTR(int* p) {
> 
> int a = 12;
> 
> p = &a; 
> 
> }
> 
> 
> void testREFF(int& p) {
> 
> int a = 12;
> 
> p = a; 
> 
> }
> 
> 
> void main()
> 
> {
> 
> int a = 10;
> 
> int* b = &a;
> 
> testPTR(b);//改变指针指向，但是没改变指针的所指的内容
> 
> cout << a << endl;// 10
> 
> cout << *b << endl;// 10
> 
> a = 10;
> 
> testREFF(a);
> 
> cout << a << endl;//12
> 
> }
> ```
> 
> 
> 
> 在编译器看来, int a = 10; int &b = a; 等价于 int * const b = &a; 而 b = 20; 等价于 *b = 20; 自动转换为指针
>
> 和自动解引用

```cpp
#include<bits/stdc++.h>//指针类型无论char.int.double都是8字节。
using namespace  std;
int main(){
     char a = 0;//int double
     char &b = a;
     char *p = &a;
     cout<<sizeof a<< sizeof b <<sizeof p<<endl;
    return 0;
}
// int char double
// 448 118 888
```



#### 4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

> 1.需要**==返回==函数内==局部变量的内存==**的时候==用指针==。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而==返回局部变量的引用是没有意义的==
>
> 2.对**==栈空间大小==比较敏感**（比如递归）的时候使用==引用==。使用**==引用传递不需要创建临时变量==，==开销要更小==**
>
> 3.**<u>==类对象作为参数传递的时候使用引用==</u>**，这是C++类对象传递的标准方式//pac!

#### 5、堆和栈的区别

> 1.申请**方式**不同。
>
> 栈由**系统自动分配**。
>
> 堆是**自己申请和释放**的。
>
> 2.申请**大小限制**不同。
>
> **栈顶和栈底是之前预设**好的，栈是**向栈底扩展，大小固定**，可以通过ulimit -a查看，**由ulimit -s修改。**
>
> 堆**向高地址扩展**，是**不连续**的内存区域，**大小可以灵活调整**。
>
> 3.申请**效率**不同。
>
> 栈由**系统分配，速度快，不会有碎片**。
>
> 堆由**程序员分配，速度慢，且会有碎片**。
>
> 栈空间默认是4M, 堆区一般是 1G - 4G 

> 计算机内存分了代码段（.text段）、初始化的数据段（.data段）、未初始化的数据段（.bss段）、堆空间（heap）、栈空间（stack）和命令行参数和环境变量区域。
>
> 程序计数器(Program Counter，简称PC)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。
>
> 因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；
>
> heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把==栈底设置在高地址区间，然后让栈向下增长==。
>
> 这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。

![typical memory arrangement](E:\笔记\图片库\609d0705b54d7ddaf46a227e0f2860e2.jpeg)

> 栈由高地址向低地址扩展的优点:(高地址是栈底，栈向下增长，低地址是栈顶)
> stack从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。
>
> 并且**这样设计可以使得堆和栈能够充分利用空闲的地址空间。**如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。
>
> 所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！
> 

|              | 栈                                                           | 堆                                                           |
| ------------ | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 管理方式     | **栈中资源由编译器自动管理，无须手动控制**                   | **堆中资源由程序员控制**                                     |
| 内存管理机制 | 只要**栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。**（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） | 系统有一个**记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序**（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） |
| 空间大小     | 栈是一块**连续的内存区域**，**大小是操作系统预定好**的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） | 堆是**不连续**的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以**堆的空间比较灵活，比较大** |
| 碎片问题     | 对于栈，它是有点**类似**于数据结构上的一个**先进后出的栈**，**进出一一对应，==不会产生碎片==**。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） | **==频繁的new/delete会造成大量碎片==**                       |
| 生长方向     | **栈向下，向低地址方向增长。**                               | **堆向上，向高地址方向增长。**                               |
| 分配方式     | 栈有**==静态分配和动态分配==**，**静态分配由编译器完成**（如**局部变量**分配），**动态分配由alloca函数分配**，但栈的**动态分配的资源由编译器进行释放，无需程序员实现**。 | ==**堆都是动态分配（没有静态分配的堆）**==                   |
| 分配效率     | 栈是其**系统提供的数据结构**，计算机在**底层对栈提供支持**，**==分配专门寄存器存放栈地址，栈操作有专门指令==。** | 堆由C/C++**==函数库==**提供，**机制很复杂。所以堆的效率比栈低很多。** |

**形象的比喻**

> 栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
>
> 
>
> 堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

#### 6、你觉得堆快一点还是栈快一点？

> 毫无疑问是栈快一点。
>
> 因为操作系统会在**底层对栈提供支持**，会分配==**专门的寄存器存放栈的地址**，栈的**入栈出栈操作也十分简单**，并且有**专门的指令执行**，所以栈的**效率比较高也比较快**。==
>
> 而堆的操作是由C/C++**==函数库提供**的，在**分配堆内存**的时候需要一定的算法**寻找合适大小的内存==**。并且==**获取堆的内容需要两次访问**，**第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。**==

#### 7、区别以下指针类型？

```cpp
int *p[10]//指针数组：不强调指针，强调数组。是一个存int型指针变量大小为10的数组
int (*p)[10]//数组指针：强调指针 pac：只有(*p)才是强调指针概念，p指向int型大小为0的数组。由于[]的优先级高于*,所以必须添加(*p).
int *p(int)//p是带int类型参数的函数，函数返回值为int*类型
int (*p)(int)//pac：强调指针，p指向一个带有int类型参数的且返回值为int的函数
```

> ==int *p[10];表示指针数组，强调数组概念，p是一个数组变量，数组大小为10**，数组内**每个元素都是指向int类型的指针变量。==
>
> 
>
> ==pac:如果不加括号，就是把(int *) 看做一个部分，(p[10])看做一个部分。自然可以知道，是int *类型的长度为10的int类型指针数组。==

> ==int (*p)[10]表示数组指针，强调p是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。==
>
> 
>
> ==pac:(int) (*p)[10];加了括号，就是将( *p)看做一个整体。前面int和[10]代表是一个int类型的数组，而p是一个指针，指向这个长度为10的int类型数组。==

> int *p(int)是**函数声明**，**函数名是p**，**参数是int**类型的，**返回值是int ***类型的。
>
> 
>
> pac:同上不加括号，(int *) 看做一部分，(p(int))一部分。p包含int类型参数，反回值是int * 类型。

> int (*p)(int)是**函数指针**，**<u>强调是指针</u>**，该**<u>指针指向的函数具有int类型参数，并且返回值是int类型的</u>**。
>
> 
>
> pac:(int) (*p)(int);加了括号，就是将( *p)看做一个整体。==p是一个指针，指向这个带有int类型参数的 返回值为int的函数。==

#### 8、new / delete 与 malloc / free的异同

> **相同点**
>
> <u>都可用于==内存的动态申请和释放==</u>
>
> **不同点**
>
> <u>前者是C++==运算符==，后者是C/C++语言==标准库函数==</u>
>
> <u>new==自动计算==</u>要分配的<u>空间大小</u>，<u>malloc需要==手工计算==</u>
>
> <u>==new是类型安全==</u>的，<u>malloc不是</u>。例如：(因为new返回具体类型指针(如果类型不匹配报错)，ma返回void类型(void需要显式类型转换为需要的类型))
>
> ```cpp
> int *p = new float[2]; //编译错误 Cannot initialize a variable of type 'int *' with an rvalue of type 'float *'
> 
> int *p = (int*)malloc(2 * sizeof(double));//编译无错误
> ```
>
> new调用名为**operator new**的==标准库函数分配====足够空间==并调用相关对象的构造函数，==delete==对指针所指对象==运行==适当的==析构函数==；然后通过==调用==名为**==operator delete==**的标准==库函数释放该对象所用内存==。
>
> 
>
> ==后者均没有相关调用==。
>
> ==后者需要库文件支持==，前者不用。
>
> ==new是封装了malloc，直接free不会报错==，但是这==只是释放内存，而不会析构对象==。
>
> (new对应delete，malloc对应free，new封装malloc，如果只free，只实现回收功能会释放内存，但是不会析构对象。)

#### 9、new和delete是如何实现的？

> new的实现过程是：首先==调用==名为**operator ==new==**的标准==库函数==，==分配==足够大的原始为==类型化的====内存==，
>
> 以==保存==指定类型的一个==对象==；接下来==运行==该类型的一个==构造函数==，用==指定初始化构造对象==；最后返回
>
> ==指向新分配并构造后的的对象的指针==
>
> 
>
> delete的实现过程：对指针指向的对象==运行适当的析构函数==；然后通过==调用名为**operator delete**的标准库函数释放该对象所用内存==

#### 10、malloc和new的区别？

> malloc和free是==标准库函数，支持覆盖==；new和delete是==运算符，支持重载==。
>
> 
>
> ==malloc仅仅分配内存空间，free仅仅回收空间==，==不==具备调用==构造函数==和==析构函数==功能，用malloc==分配空间====存储类的对象====存在风险==；new和delete==除了分配==回收功能外，还会==调用构造函数和析构函数。==
>
> 
>
> ==malloc和free返回的是void类型指针（必须进行类型转换）==，==new和delete返回的是具体类型指针。==所以前面new编译错误，malloc编译正确。

#### 11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

> malloc/free和new/delete都是用来申请内存和回收内存的。
>
> 
>
> 在==对非基本数据类型的对象使用==的时候，==对象创建的时候还需要执行构造函数==，==销毁的时候要执行析构函数==。而malloc/free是==库函数==，是==已经编译的代码==，所以不能把构造函数和析构函数的功能强加给malloc/free，所以==new/delete是必不可少的==。

#### 12、被free回收的内存是立即返还给操作系统吗？

> 不是的，被==free回收==的内存会==首先被ptmalloc使用双链表保存起来==，当用户==下一次申请内存==的时候，会尝试==从这些内存中寻找==合适的返回。这样就==避免了频繁的系统调用==，==占用过多的系统资源==。同时ptmalloc==也会尝试对小块内存进行合并==，==避免过多的内存碎片==。

#### 13、#define宏定义和函数有何区别？

> 宏在==编译时完成替换==，==之后被替换的文本参与编译==，相当于==直接插入了代码==，运行时==不存在函数调==
>
> ==用，执行起来更快==；
>
> 函数==调用在运行时需要跳转到具体调用函数==。==宏定义==属于在结构中插入代码，==没有返回值==；==函数调用具有返回值==。
>
> 
>
> ==宏定义参数没有类型，不进行类型检查==；
>
> ==函数参数具有类型，需要检查类型==。
>
> 
>
> ==宏定义不要在最后加分号==。

#### 14、#define宏定义和内联函数的区别？

> [参考1](https://blog.csdn.net/jiechuhoudeshang/article/details/90299466?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90299466-blog-48712453.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90299466-blog-48712453.pc_relevant_default&utm_relevant_index=1)
>
> [参考2](https://blog.csdn.net/will130/article/details/48712453)

> - 在使用时，宏只做==简单字符串替换（编译前==）。而内联函数可以==进行参数类型检查（编译时==），且==具有返回值==。
>
> - 内联函数在==编译时直接将函数代码嵌入到目标代码==中，==省去函数调用==的开销来提高执行效率，并且==进行参数类型检查==，==具有返回值，可以实现重载==。
>
> - 宏定义时要注意书写（参数要括起来）否则容易==出现歧义==，内联函数==不会产生歧义==
>
> - 内联函数有==类型检测、语法判断==等功能，而宏没有。
>
> 内联函数适用场景:
>
> 使用==宏定义的地方都可以使用 inline 函数==。
>
> 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。

> 1.内联函数在运行时==可调试==，而==宏定义不可以==;
> 2.编译器会对内联函数的==参数类型做安全检查或自动类型转换==（同普通函数），而宏定义则不会； 
> 3.内联函数可以==访问类的成员变量==，宏定义则不能； 
> 4.在类中声明同时定义的成员函数，自动转化为内联函数。
>
> 内联函数和普通函数相比可以**==加快程序运行的速度==**，因为不需要[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)调用，在**编译**的时候内联函数可以**直接被镶嵌到目标代码**中。
>
> 内联函数要做**参数类型检查**，这是内联函数跟宏相比的优势。
>
> inline是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。**对于短小的代码来说，inline可以带来一定的效率提升**，而且和C时代的宏函数相比，inline **更安全可靠**。可是这个是以**==增加空间消耗为代价==**的。至于是否需要inline函数就需要根据你的实际情况取舍了。
>
> inline一般只用于如下情况：
>
> > （1）一个函数==不断被重复调用==。
> >
> > （2）函数==只有简单的几行，且函数不包含for、while、switch语句==。
>
> 宏在C语言里极其重要，而在C++里用得就少多了。关于宏的第一规则是：绝不应该去使用它，除非你不得不这样做。几乎每个宏都表明了程序设计语言里或者程序里或者程序员的一个缺陷，因为它将在编译器看到程序的正文之前重新摆布这些正文。宏也许是许多程序设计工具的麻烦。所以，如果你使用了宏，你就应该准备着只能从各种工具（如排错系统、交叉引用系统、轮廓程序等）中得到较少的服务。
>
> **宏是在代码处不加任何验证的简单替代，而==内联函数是将代码直接插入调用处==，而==减少了普通函数调用时的资源消耗==。**
>
> **宏不是函数，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体**。
>
> **==inline函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处==。**
>
> ```cpp
> inline fact(float i) { return i * i; } // 没有写返回值的
> printf("bb= %d", fact(8)); // 调用时就是执行printf("bb= %d", 8*8);
> ```
>
> 关于类的例子如下：
>
> ```cpp
> Class A
> {
> public：
>     int readTest（）
>     {
>         return nTest；
>     }
>     void setTest（int i);
> };
> inline void A::setTest(int i)
> {
>     nTest=i;
> };
> ```
>
> **类A的成员函数readTest（）和setTest（）都是内联函数，readTest（）函数的定义体被放在类声明之中，因而readTest（）自动转换成inline函数，setTest函数的定义体在类声明之外，因此要加上inline关键字。**

> 1.宏定义：本例子需要注意括号的使用，不然歧义。并且本例宏定义实现是错误的。
>
> `#define MAX(a，b) ((a)>(b)?(a):(b))`
> ``MAX(a,"Hello")；`` //==错误地比较int和字符串，没有参数类型检查==
>
> 
>
> 2.内联函数：
>
> ```cpp
> #include <stdio.h>
> 
> inline int add(int a, int b)
> {
>  return (a + b);//pac
> }
> 
> int main(void)
> {
>  int a;
> 
> a = add(1, 2);//pac
> printf("a+b=%d\n", a);
> 
> return 0;
> 
> }
> ```
>
> ==以上a = add(1, 2);处在编译时将被展开为：a = (a + b);==
>
> 
>
> 3、使用时的一些注意事项：
>
> - 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
>
> - inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
> - 同其它函数不同的是，==最好将inline函数定义在头文件==，而不仅仅是声明，因为编译器在处理inline函数时，==需要在调用点内联展开该函数==，所以==仅需要函数声明是不够的==。
>
> 4、内联函数使用的条件：
>
> 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况==不宜使用内联==： 
> （1）如果函数体内的==代码比较长，使用内联将导致内存消耗代价较高==。 
> （2）如果函数体内出现==循环，那么执行函数体内代码的时间要比函数调用的开销大==。 
> 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。
>
> 
>
> 5、使用内联函数和宏函数可能带来的问题（慎用）：
>
> 有时不要仅是为了提高编程效率而使用这两种函数，要综合考虑后再使用，因为有时使用这两种函数可能带来其他的问题，比如出现问题不能使用gdb调试问题，内联函数不展开，宏函数没有参数检测等

#### 15、#define宏定义和const的区别

> **编译阶段**
>
> ==define是在编译的**预处理**阶段==起作用，而==const是在编译、运行的时候起==作用
>
> **安全性**
>
> ==define只做替换，不做类型检查和计算，也不求解，容易产生错误==，一般最好加上一个大括号包含住
>
> 全部的内容，要不然很容易出错
>
> ==const常量有数据类型，编译器可以对其进行类型安全检查==
>
> **内存占用**
>
> define只是==将宏名称进行替换，在内存中会产生多分相同的备份==。
>
> ==const==在程序==运行中只有一份备份，==且可以==执行常量折叠==，==能将复杂的的表达式计算出结果放入常量表。==
>
> 
>
> 宏替换发生在==编译阶段之前==，属于==文本插入替换==；const作用发生于==编译过程中==。
>
> 
>
> 宏定义的数据==没有分配内存==空间，只是插入替换掉；==const定义的变量只是值不能改变，但要分配内存空间。==

#### 16、#define宏定义和typedef区别？

> 宏==主要用于定义常量及书写复杂的内容==；typedef==主要用于定义类型别名==。
>
> 
>
> 宏替换发生在==编译阶段之前==，属于==文本插入替换==；typedef是编译的一部分。
>
> 
>
> 宏==不检查类型==；==typedef会检查数据类型==。
>
> 
>
> ==宏不是语句，不在在最后加分号==；==typedef是语句，要加分号标识结束==。
>
> 
>
> 注意==对指针的操作==，typedef char * p_char和#define p_char char *区别巨大。(pac:因为define是替换，他只能替换一个！！！)
>
> ```cpp
> typedef    (int*)   p1;
> p1 a, b;//代表 int * a, * b;
> ```
>
> 以及下面这行:
>
> ```
> #define    p2    int*
> p2 a, b;//代表 (int*) a,  b;因为define只能简单的替换，替换之后为int * a,b;只替换一次.前面a是整形指针变量，后面的b是整型变量
> ```
>
> 效果相同？实则不同！实践中见差别：
>
> **p1 a,b;的效果同int *a; int *b;**表示**定义了两个整型指针变量**。
>
> 而**p2 a,b;的效果同int *a, b;**表示**定义了一个整型指针变量a和整型变量b**

#### 17、常量指针和指针常量区别？

> ==指针常量==是一个指针，==读成常量的指针，指向一个只读变量==，也就是==后面所指明的int const 和 const int，都是一个常量==，可以写作==int const *p或const int *p==。
>
> 
>
> ==常量指针是一个不能给改变指向的指针==。==指针是个常量==，==必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了==，即不能中途改变指向，如==int *const p==。
>
> 
>
> 多说一句，网上关于指针常量和常量指针的说法很多跟书本上都不一致，甚至百度百科上跟《C++ Primer 5th》书上在指针常量和常量指针的说法刚好相反，鉴于百度百科是人人都可以去编辑，因此我信书。也希望各位遇到问题时要多去查阅资料，多去确认，不要因为某些博客或者文章说了就确认无疑。

#### 18、a和&a有什么区别？

> 假设数组==int a[10]; int (*p)[10] = &a==;其中：
>
> ==a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小==，如果a的值是0x00000001，加
>
> 1操作后变为0x00000005。*(a + 1) = a[1]。
>
> &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首
>
> 地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
>
> 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

#### 19、C++和Python、Java、C的区别

> 1.包括但不限于：
>
> Python是一种==脚本语言，是解释执行==的，而C++是==编译语言，是需要编译后在特定平台运行==的。
>
> python可以很方便的==跨平台==，但是==效率没有C++高==。
>
> Python使用==缩进来区分不同的代码块==，C++==使用花括号==来区分
>
> C++中需要==事先定义变量的类型==，而==Python不需要==，Python的==基本数据类型只有数字，布尔值，字符串，列表，元组等等==
>
> Python的==库函数比C++的多，调用起来很方便==
>
> ```cpp
> int main(int argc, char const *argv[]){
> 
> 
> 
> const char* str = "name";
> 
> sizeof(str); // 取的是指针str的长度，是8
> 
> strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
> 
> return 0;
> 
> }
> ```
>
> 
>
> 2、C++和C语言的区别
>
> (1)C++中==new和delete是对内存分配的运算符，取代了C中的malloc和free==。
>
> (2)标准C++中的==字符串类==取代了标准C函数库头文件中的==字符数组处理函数==（C中没有字符串类型）。
>
> (3)C++中用来做控制态输入输出的==iostream类==库替代了标准C中的==stdio函数库==。
>
> (4)C++中的==try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数==。
>
> (5)在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别
>
> 开来。而这在C语言中是不允许的。也就是==C++可以重载，C语言不允许==。
>
> (6)C++语言中，==允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以==；而C语言中，必
>
> 须要==在函数开头==部分。而且C++==允许重复定义变量==，==C语言也是做不到==这一点的
>
> 在C++中，除了值和指针之外，==新增了引用==。引用型变量是其他变量的一个别名，我们可以认为他们
>
> 只是名字不相同，其他都是相同的。
>
> C++相对与C==增加了一些关键字==，如：bool、using、dynamic_cast、namespace等等
>
> 
>
> #### 21、C++与Java的区别
>
> **语言特性**
>
> Java语言给开发人员提供了==更为简洁==的语法；==完全面向对象==，由于JVM可以安装到任何的操作系统
>
> 上，所以说它的==可移植性强==
>
> 
>
> Java语言中==没有指针==的概念，==引入了真正的数组==。==不同于C++中利用指针实现的“伪数组”==，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于==防止==在C++程序中常见的因为
>
> 数组操作越界等指针操作而对系统数据进行非法读写带来的==不安全问题==
>
> 
>
> C++也可以==在其他系统运行，但是需要不同的编码==（这一点==不如Java，只编写一次代码，到处运==
>
> ==行==），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成
>
> 字节码，在JVM里面运行得到结果
>
> 
>
> ==Java用接口(Interface)技术取代C++程序中的抽象类==。接口与抽象类有==同样的功能==，但是==省却了在实现和维护上的复杂性==
>
> 
>
> **垃圾回收**
>
> C++用==析构函数回收垃圾==，写C和C++程序时一定要==注意内存的申请和释放==
>
> Java语言不使用指针，==内存的分配和回收都是自动进行==的，程序员==无须考虑内存碎片==的问题
>
> 
>
> **应用场景**
>
> Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，==指针是c++的优势，可以直接对内存==
>
> ==的操作，但同时具有危险性== 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错
>
> 误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）
>
> 
>
> Java在Web 应用上具有C++ 无可比拟的优势，具有==丰富多样的框架==对于==底层程序的编程以及控制方面的编程==，==C++很灵活，因为有句柄的存在== 
>
> > 句柄：Windows系统中有许多内核对象（这里的对象不完全等价于"面向对象程序设计"一词中的"对象"，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个"对象"的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：
> >
> > 1. 暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；
> > 2. 操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？
> >
> > 所以，Windows操作系统就采用进一步的间接：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。
> >
> > 在Windows系统中，这个编号就叫做"句柄"。
> >
> > 
> >
> > ==我的理解==
> >
> > ==其实，句柄是一个指向指针的指针==。即：在*windows*程序设计中，句柄仅是一个应用程序用来识别某些事情的数字如果想更透彻一点地认识句柄，我可以告诉大家，句柄是一种指向指针的指针。我们知 道，所谓==指针是一种内存地址==。应用==程序启动后，组成这个程序的各对象是住留在内存的== 。如果简单地理解，似乎我们==只要获知这个内存的首地址==，那么就可以==随时用这个地址访问对象==。==但是==，如果您真的这样认为，那么您就大错特错了。我们知道，*Windows*是一个==以虚拟内存为基础==的操作系统。在这种系统环境下，*Windows*==内存管理器经常在内存中来回移动对象==，依此来==满足各种应用程序的内存需要==。==对象被移动意味着它的地址变化 了。如果地址总是如此变化，我们该到哪里去找该对象呢==*?为了解决这个问题，*Windows*操作系统为各应用程序==腾出一些内存储地址==，用来专门 ==登记各应用对象在内存中的地址变化==，而这个==地址*(*存储单元的位置*)*本身是不变的==。*Windows*内存管理器在==移动对象在内存中的位置后==，把对象==新的地址告知这个句柄地址来保存==。这样我们==只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置==。这个==地址是在对象装载*(Load)*时由系统分配给的，当系统卸载时*(Unload)*又释放给系统== 。
> >
> > 
> >
> > ==句柄地址*(*稳定*)→*记载着对象在内存中的地址*→*对象在内存中的地址*(*不稳定*) →*实际对象==但是，必须注意的是==程序每次从新启动==，系统==不能保证分配给这个程序的句柄还是原来的那个句柄==，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。
> >
> > 
> >
> > https://blog.csdn.net/XJF199001/article/details/45955353?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-45955353-blog-78198831.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-45955353-blog-78198831.pc_relevant_default&utm_relevant_index=1

#### 22、C++中struct和class的区别

> **相同点:**
>
> 两者==都拥有成员函数、公有和私有部分==
>
> 任何==可以使用class完成的工作，同样可以使用struct完成==
>
> 
>
> **不同点:**
>
> (1)**==默认成员权限区别==**:两者中如果不对成员不指定公私有，==struct默认是公有==的，==class则默认是私有==的
>
> (2)**==默认继承方式==**:==struct模式是public继承==，==而class默认是private继承==
>
> ```cpp
> //1成员权限：
> struct Sb{ void f( void ) { } };
> struct Sc : Sb{ };
> class Cb{ void f( void ) { } };
> class Cc1 : public Sb{ };
> class Cc2 : Sb{ };
> sb.f(); // 合法
> cb.f(); // 不合法，因为在Cb类中f( )函数默认为private，此处不可访问
> 
> //2继承方式：
> Sc sc; Cc1 cc1; Cc2 cc2;
> sc.f(); // 合法
> cc1.f(); // 合法，因为Cc1显示地使用public继承
> cc2.f(); // 不合法，Cc2默认private继承自Sb，在Cc2中f( )为private
> 
> 在C语言中struct不可以继承，虽然我们知道在C++中struct可以继承，但在实际使用中，在不需要继承的场合我们使用struct，而在需要继承的场合使用class，这样更贴近其字面意思，使程序有更好的可读性。
> ```
>
> 
>
> **引申：C++和C的struct区别**:
>
> (1)==C==语言中：==struct是用户自定义数据类型==（UDT）；==C++中struct是抽象数据类型==（ADT），==支持成员函数的定义，（C++中的struct能继承，能实现多态）==
>
> 
>
> (2)==C中struct是没有权限==的设置的，且struct中==只能是一些变量的集合体==，==可以封装数据却不可以隐藏数据，而且成员**不可以是函数**==
>
> 
>
> (3)C++中，==struct增加了访问权限==，==且可以和类一样有成员函数==，==成员默认访问说明符为public（为了与C兼容）==
>
> 
>
> (4)struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在==C中==必须在结构标记==前加上struct==，才能做==结构类型名==（除：typedef struct class{};）
>
> C++中==结构体标记（结构体名）可以直接作为结构体类型名使用==，此外==结构体struct在C++中被当作类的一种特例==
>
> 
>
> (5)==结构体和类主要的区别就是一个是值类型，一个是引用类型==；==值类型是写时复制的，引用类型是不会发生写时复制的==；当我们需要一个==简单不需要继承、不多变的数据时候我们首选结构体==，因为在数据结构上来说==结构体的存取效率是高于类的==，反之当我们需要一个==数据结构比较大，需要继承，变化比较多的时候我们选择类，因为在变化的过程中结构体可能会发生写时复制，而类不会==；
>
> 
>
> (6)==class 可以使用模板，而 struct 不能==.
>
> C++中声明一个函数或者类的模板支持两种关键字class和typename：
>
> ```cpp
> template <class T>
> struct Person
> {
> public:
>     T age;
> };
> 
> 或
> 
> template <typename T>
> struct Teacher
> {
> public:
>     T age;
> };
> ```
>
> 在C++中[struct](https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020)和class关键字基本上是等价的，因为要兼容C语言，所以C++保留了struct关键字并且它等价于class关键字，那么在模板里面是不是可以用struct替代class呢？ 
>
> 答案是否定的，会出现下面的编译错误：
>
> ```cpp
> template <struct T>
> struct Person
> {
> public:
>     T age;
> };
> ```
>
> ![img](E:\笔记\图片库\Center.bmp)
>
> 想必这也在预料中，C++保留struct关键字主要是为了兼容C语言，但是在C语言中是不存在模板的，所以没有必要再模板中支持struct声明模板形参。
>
> 模板为C++语言新增特性，C语言没有，只有class可用于定义参数，而struct不可以，例如： 
>
> ```cpp
> template
> class TValue {
> private: T _v;
> public: TValue(T v) : _v(v){}
> T Get( void ) { return _v; }
> };
> ```
>
>   此处只能使用class，不能使用struct。当然，此处还可以使用typename代替class，class与typename也仅在定义模板参数时可以互换，而且建议此时使用typename，因为这样读起来更接近人类语言，更具有可读性。

#### 23、变量声明和定义区别？

> ==声明仅仅==是把==变量的声明的位置及类型提供给编译器==，并==不分配内存空间==；==定义要在定义的地方为其分配存储空间==。
>
> 相同变量可以在==多处声明（外部变量extern==），但只能在==一处定义。==

#### 24、C++中const和static的作用(待看)

> **static**
>
> 
>
> 不考虑类的情况：
>
> (1)隐藏。所有==不加static的全局变量和函数具有全局可见性==，可以在其他文件中使用，==加了之后只能在该文件所在的编译模块中使用==
>
> (2)==默认初始化为0==，包括未初始化的全局静态变量与==局部静态==变量，都存==在全局未初始化区==
>
> (3)静态变量在==函数内定义，始终存在，且只进行一次初始化，具有记忆性==，其==作用范围与局部变量相同==，==函数退出后仍然存在，但不能使用==  
>
> 
>
> 考虑类的情况:
>
> static成员变量：==只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化==，
>
> 必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
>
> static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const**、虚函数和volatile**；可以被非static成员函数任意访问。
>
> 
>
> **const**
>
> 不考虑类的情况
>
> 
>
> const常量在定义时必须初始化，之后无法更改
>
> const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const 
>
> int& i){ //...}
>
> 
>
> 考虑类的情况
>
> const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须
>
> 有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
>
> const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非
>
> mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

#### 25、C++的顶层const和底层const

==**顶层**const==：指的是const修饰的==**变量本身**==是一个==常量==，无法修改，指的是==指针，就是 * 号的右边==，顶层代表本身

==**底层**const==：指的是const修饰的==**变量所指向的对象**==是一个常量，指的是==所指变量==，就是 ==* 号的左边==，底层代表他所指向的对象(底层)。

**举个例子**

```cpp
int a = 10;
int* const b1 = &a; //顶层const，b1本身是一个常量
const int* b2 = &a; //底层const，b2本身可变，所指的对象是常量
const int b3 = 20; //顶层const，b3是常量不可变
const int* const b4 = &a; //前一个const为底层，后一个为顶层，b4不可变

const int& b5 = a; //pac是底层不是顶层:用于声明引用变量，都是底层const
```

**区分作用**

> 执行==对象拷贝时有限制==，常量的==底层const不能赋值给非常量的底层const==
>
> 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const
>
> ```cpp
> const int a;
> int const a;
> const int *a;
> int *const a;
> ```
>
> int const a和const int a均表示定义常量类型a。
>
> const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
>
> int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

指针和const的用法:

(1) 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。

(2)int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量

(3)int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。

#### 26、数组名和指针（这里为指向数组首元素的指针）区别？

> 二者==均可通过增减偏移量来访问数组中的元素==。
>
> 
>
> ==数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作==。
>
> 
>
> **当==数组名当做形参传递给调用函数==后，就==失去了原有特性，退化成一般指针，多了自增、自减操作==，**
>
> ==但sizeof运算符不能再得到原数组的大小==了。//pac

#### 27、final和override关键字

**override**

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```cpp
class A 
{
 virtual void foo();
}

class B : public A 
{
 void foo(); //OK
 virtual void foo(); // OK
 void foo() override; //OK
}
```

> 如果不使用override，当你手一抖，将**foo()**写成了**f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器不会编译通过的：

```cpp
class A {
 virtual void foo();
};
class B : public A {
 virtual void f00(); //OK，这个函数是B新增的，不是继承的
 virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找
不到就报错
};
```

**final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：

```cpp
class Base
{
 virtual void foo();
};
class A : public Base
{
 void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写
};
class B final : A // 指明B是不可以被继承的
{
 void foo() override; // Error: 在A中已经被final了
};
class C : B // Error: B is final
{
};
```

#### 28、拷贝初始化和直接初始化

> //拷贝：<u>用指定构造函数创建临时对象，调用拷贝函数临时对象拷贝到创建对象。</u>
>
> //直接：<u>直接调用实参匹配的构造函数。</u>
>
> 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：==直接初始化直接调用与实参匹配的构造函数==，==拷贝初始化总是调用拷贝构造函数==。拷贝初始化首先使用==指定构造函数创建一个临时对象==，然后用==拷贝构造函数==将那个==临时对象拷贝到正在创建的对象==。举例如下:

```cpp
//括号内是直接初始化
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化

//括号外是拷贝初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

> **==为了提高效率，允许编译器跳过创建临时对象==这一步，**直接调用构造函数构造要创建的对象，这样就完全等价于**直接初始化了**（语句==1和语句3等价==），但是需要辨别两种情况。
>
> 
>
> 当==拷贝构造函数为private时：语句3和语句4在编译时会报错==。//pac
>
> 
>
> 使用==explicit修饰构造函数==时：如果==构造函数存在隐式转换，编译时会报错==。//pac

#### 29、初始化和赋值的区别

> 对于简单类型来说，初始化和赋值没什么区别对于类和复杂数据类型来说，这两者的区别就大了，举例如下：
>
> https://www.cnblogs.com/lxy-xf/p/11049963.html
>
> 关于构造函数，前面有两篇随笔写了==默认构造函数和拷贝构造函数==，其实还包括参数为一些成员变量属性的构造函数，现在自己理一下，这两个东西，他们只是参数不同，也就是说只是使用他们的方式不同。==默认构造函数是不传参==，构建的对象默认的使用那些值赋值给成员变量；而==拷贝构造==函数是接受一个相同类的另一个==临时对象==，使用该==临时对象来成员的为自己的成员赋值==；其他的一些构造函数也是如此，他们只是走的路线不同，==**最终目的都是为构建的一个对象进行初始化。**也就是说，构造函数的目的，是服务于类的初始化的，它并不服务于赋值。赋值是独立于初始化之后的操作。==

```cpp
class A{
public:
 int num1;
 int num2;
public:
 A(int a=0, int b=0):num1(a),num2(b){};//如果a(x,y)xy没有传参的时候初始赋值，那么就用默认初始值00，对其赋值。
 A(const A& a){};
 //重载 = 号操作符函数
 A& operator=(const A& a){
 num1 = a.num1 + 1;
 num2 = a.num2 + 1;
 return *this;
 };
};
int main(){
 A a(1,1);
 A a1 = a; //拷贝初始化操作，调用拷贝构造函数
 A b;
 b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
 std::cout<<a.num1<<a.num2<<' '<<a1.num1<<' '<<a1.num2<<' '<<b.num1<<b.num2;//11 14948128 0 22为何？a1.num1是随机数，而num2是0? 按照理论应该是 1.1
 return 0; }
```

> 并不像我们想象的那样a1为(2,2),b也为(2,2)。这正是初始化与赋值的区别。
>
> 
>
> 在p1中，==A a1 = a;==这个操作中，实际上是通过一种==类似于拷贝构造函数中逐member的方式（但并没有生成一个拷贝构造函数==，生成拷贝构造函数的四种情况见34的随笔），==pac:并没有调用重载的"="运算符==。所以最终结果是a1为(1,1)。
>
> ==**为何这里运行结果不一样？**==
>
> 而在p2中，==初始化与赋值是分开的==，==A b;就已经完成了初始化==，这个==初始化是通过定义的含参构造函数（但是以a=0,b=0的默认值完成的）==。
>
> ==然后再调用重载运算符==，对==p中成员均自加后赋值给p2的成员变量==。

#### 30、extern"C"的用法

> 为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
>
> 哪些情况下使用extern "C"： 
>
> （1）==C++代码中调用C语言代码==；
>
> （2）在==C++中的头文件==中使用；
>
> （3）在==多个人协同开发==时，可能有人擅长C语言，而有人擅长C++；
>
> 举个例子，C++中调用C代码：

```cpp
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__
extern "C"{
 typedef unsigned int result_t;
 typedef void* my_handle_t;
 
 my_handle_t create_handle(const char* name);
 result_t operate_on_handle(my_handle_t handle);
 void close_handle(my_handle_t handle);
}
```

> 综上，总结出使用方法，在==C语言的头文件中，对其外部函数只能指定为extern==类型，==C语言中不支持extern "C"==声明，在.c文件中包含了extern "C"时会出现编译语法错误。所以使用==extern "C"全部都放在于cpp程序相关文件或其头文件==中。
>
> 总结出如下形式：
>
> （1）==C++调用C==函数：
>
> ```cpp
>//xx.h
> extern int add(...)
> //xx.c
> int add(){
> }
> //xx.cpp
> extern "C" {
> \#include "xx.h"
> }
>  ```
> 
> （2）==C调用C++==函数
>
> ```cpp
>//xx.h
> extern "C"{
> int add();
> }
>  //xx.cpp
> int add(){ 
> }
> //xx.c
> extern int add();
> ```

#### 31、野指针和悬空指针

>  ==都是是指向无效内存区域==(这里的无效指的是"==不安全不可控==")的指针，访问行为将会==导致未定义行为。==
>
> ==野指针，指的是没有被初始化过==的指针。因此，为了防止出错，对于指针初始化时都是赋值为nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。

```cpp
int main(void) { 
  int* p; // 未初始化
 std::cout<< *p << std::endl; // 未初始化就被使用
  return 0; }

int main(void) {
    int* p =nullptr; 
    std::cout<< *p <<' '<<p<< std::endl; // *p还是会退出(进程已结束，退出代码为 -1073741819 (0xC0000005))，p返回0.
    return 0; }
```

> 悬空指针，指针最初指向的内存已经被释放了的一种指针。

```cpp
int main(void) { 
 int * p = nullptr;
 int* p2 = new int;
  p = p2;
 delete p2; }
```

> 此时 p和p2就是==悬空指针，指向的内存已经被释放==。继续使用这==两个指针，行为不可预料==。需要设置为p=p2=nullptr。此时再使用，编译器会直接保错。
>
> ==避免野指针比较简单，但悬空指针比较麻烦==。c++引入了==智能指针，//pac:C++智能指针的本质就是避免悬空指针的产生。==

> **产生原因及解决办法：**
>
> ==野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空==。
>
> ==悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空==。

#### 32、C和C++的类型安全

##### 1、什么是类型安全？

==类型安全很大程度上可以等价于内存安全==，类型安全的代码==不会试图访问自己没被授权的内存区域==。“类型安全”==常被用来形容编程语言==，其根据在于该门编程语言是否提供保障类型安全的机制；==有的时候也用“类型安全”形容某个程序==，判别的标准==在于该程序是否隐含类型错误==。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。

##### 2、C的类型安全

C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：

printf格式输出![image-20220819133210211](E:\笔记\图片库\image-20220819133210211.png)

上述代码中，使用==%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误==

malloc函数的返回值

==malloc==是C中进行内存分配的函数，它的==返回类型是void*即空类型指针==，常常有这样的用法==char * pStr=====(char* )malloc(100 * sizeof(char))==，这里明显做了显式的类型转换。

==类型匹配尚且没有问题==，但是一旦出现==int* pInt===  ==(int* )malloc(100*sizeof(char))==就很可能带来一些问题，而这样的转换C并==不会提示错误==。

##### 3、C++的类型安全

如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安

全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*

- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；

- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换

- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全

- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

例1：使用void*进行类型转换

![image-20220819134936084](E:\笔记\图片库\image-20220819134936084.png)

例2：不同类型指针之间转换

```cpp
#include<iostream>
using namespace std;
class Parent{};
class Child1 : public Parent
{
public:
 int i;
 Child1(int e):i(e){}
};
class Child2 : public Parent
    {
public:
 double d;
 Child2(double e):d(e){}
};
int main()
{
 Child1 c1(5);
 Child2 c2(4.1);
 Parent* pp;
 Child1* pc1;
 
 pp=&c1; 
 pc1=(Child1*)pp; // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误
 cout<<pc1->i<<endl; //输出：5
 pp=&c2;
 pc1=(Child1*)pp; //强制转换，且类型发生变化，将造成错误
 cout<<pc1->i<<endl;// 输出：1717986918
 return 0; }
```

> 上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void* ，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应==尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。==

#### 33、C++中的重载(overload)、重写（覆盖override）和隐藏(hide)的区别

##### 1、重载（overload）

重载是指在==同一范围定义中的**同名成员函数**才存在重载关系==。主要特点是==函数名相同==，==参数类型和数目有所不同==，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。==重载和函数成员是否是虚函数无关==。举个例子：

```cpp
class A{
 ...
 virtual int fun();
 void fun(int);
 void fun(double, double);
 static int fun(char);
 ...
}
```

> **函数重载：**在作用域中,函数名同名，函数参数顺序类型个数不同时构成重载
>
> 使用==const 修饰也可以构成重载，使用默认参数时要注意调用时避免与其他函数存在二异性==
>
> 1)函数返回值与构成函数重载无任何关系
>
> 2)类的==静态成员函数与普通成员函数可以形成重载==
>
> 3)函数重载发生在同一作用域中，如==类成员函数之间的重载(如上面的例子，在一个class里面定义的成员函数)==、==全局函数之间的重载==
>
> 4)基类函数必须有 `virtual` 关键字，不能有 `static`，大概是多态的原因(没看懂什么意思，overload为何要有基类函数？)

##### 2、重写(覆盖)(override)

> 重写指的是在派生类中覆盖基类中的==同名函数==，**重写就是重写函数体**，**要求==基类函数必须是虚函数==**且：
>
> - 与基类的虚函数有==相同的参数个数==
>
> - 与基类的虚函数有==相同的参数类型==
>
> - 与基类的虚函数有==相同的返回值类型==
>
> 举个例子:

```cpp
//父类
class A{
public:
 virtual int fun(int a){}
}

//子类
class B : public A{
public:
 //重写,一般加override可以确保是重写父类的函数
 virtual int fun(int a) override{}
}
```

> 重载与重写的区别：
>
> - 重写是==父类和子类之间的垂直关系==，重载是==不同函数之间的水平关系==
>
> - 重写要求==参数列表相同==，重载则要求==参数列表不同，返回值不要求==
>
> - 重写关系中，==调用方法==根据==对象类型决定==，重载根据调用时==实参表与形参表的对应关系==来选择函数体



> 在C++中，函数覆盖：对于基类中存在的一个virtual修饰的函数（例如Example中Base类存在g函数），用该基类的指针指向不同子类的类对象（Example的main函数中Base *pb指向Derived d），使用该函数会产生不同的响应结果（结果为子类中所要输出的结果），实际上这也是多态的一种体现，通常也叫做动态绑定。实现原理为：派生类函数覆盖基类函数，类中如果有带virtual关键字修饰的函数，则类中会有一张虚函数表vtable，当基类的virtual 修饰的函数在子类中重新实现后，会将vtable中原基类的函数用新函数来覆盖，若用基类指针指向子类对象时，会指向子类中基类所在的位置，此时基类中的virtual修饰的函数已经被子类实现的所覆盖，所以调用的结果是子类中函数，例如Example中的g。满足条件：
>
> - 不同的范围（分别位于派生类与基类）
> - 函数名字相同
> - 参数相同
> - 基类函数必须有virtual 关键字
>
> ```cpp
> #include <iostream>
> using namespace std;
> 
> class Base
> {
> public:
>     void f(int x){ cout << "Base::f(int) " << x << endl; }
>     void f(float x){ cout << "Base::f(float) " << x << endl; }
>     virtual void g(void){ cout << "Base::g(void)" << endl;}
> };
> 
> class Derived : public Base
> {
> public:
>     virtual void g(void){ cout << "Derived::g(void)" << endl;}
> };
> 
> int main()
> {
>     Derived  d;
>     Base *pb = &d;
>     pb->f(42);        // Base::f(int) 42
>     pb->f(3.14f);     // Base::f(float) 3.14
>     pb->g();          // Derived::g(void)，返回的是derived中的g(void)!
> 
>     return 0;
> }
> 
> ```

##### 3、隐藏（hide）

隐藏指的是某些情况下，==派生类中的函数屏蔽了基类中的同名函数==，包括以下情况：

1.两个函数==参数相同，但是基类函数不是虚函数==。和==重写==的区别在于==基类函数是否是虚函数==。举个例子：

```cpp
//父类
class A{
public:
 void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};

//子类
class B : public A{
public:
 //隐藏父类的fun函数
 void fun(int a){
 cout << "B中的fun函数" << endl;
 }
};

int main(){
 B b;
 b.fun(2); //调用的是B中的fun函数
 b.A::fun(2); //调用A中fun函数
 return 0; }
```

2.两个函数==参数不同==**，**无论==基类函数是不是虚函数**，**都会被隐藏==**。**和==重载==的区别在于==两个函数不在同一个类中==。举个例子：

```cpp
//父类
class A{
public:
 virtual void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};

//子类
class B : public A{
    public:
 //隐藏父类的fun函数
 virtual void fun(char* a){
 cout << "A中的fun函数" << endl;
 }
};

int main(){
 B b;
 b.fun(2); //报错，调用的是B中的fun函数，参数类型不对
 b.A::fun(2); //调用A中fun函数
 return 0; }
```

##### 4、Overwrite（重写）(与上面有重合？)

>  重写是指派生类的函数隐藏了与其同名的基类函数。函数为no virtual,只要派生类中存在与基类同名的函数，则发生overwrite,如果有virtual 同名且同参，则发生Override,若同名不同参数发生overwrite。在Example const在派生类中的virtual函数中，同名的普通函数与const函数本质上是两个不同的函数，应该等价理解为这两个同名函数的参数是不同的。
>   注意发生overwrite，函数行为依赖于指针/引用的类型而不是指向对象的类型。发生override则取决于指向的对象。

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void f(float x){ cout << "Base::f(float) " << x << endl; }
};

class Derived : public Base
{
public:
    virtual void f(float x) const { cout << "Derived::f(float) " << x << endl; }//未发生override，而是Overwrite
};

int main()
{
    Derived  d;
    Base *pb = &d;
    Derived *pd = &d;

    // Bad : behavior depends solely on type of the object
    pb->f(3.14f); // Base::f(float) 3.14
    pd->f(3.14f); // Derived::f(float) 3.14

    return 0;
}

```

> const重载（静态）
>
> 原因：通常我们在类中定义一个函数，实际上传入的是 void Get(Base* this),这代表一个指向Base对象的指针this被传入到了Get函数中。而但对象被定义成const 时候，比如const Base a,则调用函数的时候函数中必须要有 void Get(const Base* const this),相当于void Get(Base* this) const。这就是为什么常对象只能调用常成员函数的原因。但是非常量对象可以调用常量函数，因为编译器会自动先转换为常量对象。
>
> ![img](E:\笔记\图片库\24c863b42ffb4016b8892331e18b6abc.png)
>
> ![img](E:\笔记\图片库\97ce30dffec9422caf63f478cd085e5b.png)
>
> ![img](E:\笔记\图片库\c4e1bad61b3e4bd2a4a5336b3ca09ba1.png)

#### 34、C++有哪几种的构造函数

> C++中的构造函数可以分为4类：
>
> - ==默认构造==函数（没有参数，赋值为什么，看结构体内部写的是什么）
>
> - ==初始化构造==函数（有参数）
>
> - ==拷贝构造==函数
>
> - 移动构造函数（move和右值引用）//pac
>
> - 委托构造函数
>
> - ==转换构造==函数
>
> 举个例子：

```cpp
#include <iostream>
using namespace std;
class Student{
public:
 Student(){//默认构造函数，没有参数
 this->age = 20;
 this->num = 1000;
 }; 
 Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
 Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
 this->age = s.age;
 this->num = s.num;
 }; 
 Student(int r){ //转换构造函数,形参是其他类型变量，且只有一个形参
 this->age = r;
 this->num = 1002;
 };
 ~Student(){}
public:
 int age;
 int num;
};
int main(){
 Student s1;//默认构造
 Student s2(18,1001);//初始化构造
 int a = 10;
 Student s3(a);//转移构造
 Student s4(s3);//拷贝构造
 printf("s1 age:%d, num:%d\n", s1.age, s1.num);
 printf("s2 age:%d, num:%d\n", s2.age, s2.num);
 printf("s3 age:%d, num:%d\n", s3.age, s3.num);
 printf("s2 age:%d, num:%d\n", s4.age, s4.num);
 return 0; }
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002
```

> 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
>
> 复制构造函数用于复制本类的对象
>
> 转换构造函数用于将其他类型的变量，隐式转换为本类对象

> https://blog.csdn.net/zxc024000/article/details/51153743
>
> 转换构造函数可以用在哪里？
> 假如重载了+号运算符，使得两个Student类的对象可以相加，其结果为两个对象的成员变量age之和。
>
> ```cpp
> Student s1(01,18);
> Student s2(02,20);
> s1+s2;  //其值就是s1.age + s2.age = 18+20=36。
> ```
>
> **那么 s1+19 呢(类对象与int直接相加）？ **
> 因为我们定义了 转换构造函数，那么 s1+19，执行如果过程：
> 首选调用+号运算符，发现19不是Student类的对象，而是int类型然后调用转换构造函数，将19变为Student（19）现在便可以进行加法运算，其值是s1.age+ (TempStudentObject).age=18+19 = 37

#### 35、浅拷贝和深拷贝的区别

##### 1、浅拷贝

name = s.name;

浅拷贝==只是拷贝一个指针，并没有新开辟一个地址==，拷贝的指针==和原来的指针指向同一块地址==，如果==原来的指针所指向的资源释放==了，那么==再释放浅拷贝的指针的资源就会出现错误==。

##### 2、深拷贝

name = new char(20); memcpy(name, s.name, strlen(s.name));

深拷贝==不仅拷贝值==，还开辟出一块==新的空间用来存放新的值==，即使==原先的对象被析构掉==，释放内存了==也不会影响到深拷贝得到的值==。在自己实现==拷贝赋值==的时候，如果==pac:有指针变量的话是需要自己实现深拷贝的。==

```cpp
#include <iostream> 
#include <string.h>
using namespace std;

class Student
{
private:
 int num;
 char *name;
public:
 Student(){
 name = new char(20);
 cout << "Student" << endl;
 };
    
 ~Student(){
 cout << "~Student " << &name << endl;
 delete name;
 name = NULL;
 };
    
 Student(const Student &s){//拷贝构造函数
 //浅拷贝，当对象的name和传入对象的name指向相同的地址
 name = s.name;
 //深拷贝
 //name = new char(20);
 //memcpy(name, s.name, strlen(s.name));//memcpy(x,y,z)将y开始，长度为z的字符串拷贝到x位置。
 cout << "copy Student" << endl;
 };
};

int main()
{
 {// 花括号让s1和s2变成局部对象，方便测试
Student s1;
 Student s2(s1);// 复制对象
 }
 system("pause");
 return 0; }
//浅拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffed0c3ec0
//~Student 0x7fffed0c3ed0
//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 
0x0000000001c82c20 ***
    
//深拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffebca9fb0
//~Student 0x7fffebca9fc0
```

浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。

深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。

在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给  另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也 指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

#### 36、strlen和sizeof区别？

> ==sizeof是运算符，并不是函数==，==结果在编译时得到而非运行中获得==；strlen是字符处理的==库函数。==
>
> ==sizeof参数==可以是==任何数据的类型或者数据==（sizeof参数不退化）；strlen的==参数只能是字符指针且结尾是'\0'的字符串==。
>
> 因为==sizeof值在编译时确定==，所以==不能==用来==得到动态分配（运行时分配）存储空间的大小==。

```cpp
int main(int argc, char const *argv[]){
 
 const char* str = "name";
 sizeof(str); // pac: 取的是指针  str的长度，是8
 strlen(str); // pac: 取的是这个字符串  的长度，不包含结尾的 \0。大小是4
 return 0;
 }
```

#### 37、public，protected和private访问和继承权限/public/protected/private的区别？

> - ==public的变量和函数==在==类的内部外部==都可以访问。
>
> - ==protected==的变量和函数只能在==类的内部和其派生类==中访问。
>
> - ==private修饰的元素只能在类内访问==。

##### 1、访问权限

> 派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意==外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问==。

![image-20220819181103344](E:\笔记\图片库\image-20220819181103344.png)

> 派生类对基类成员的访问形象有如下两种：
>
> ==内部==访问：由==派生类中新增的成员函数对从基类继承来的成员的访问==
>
> **==外部==访问**：在==派生类外部，通过派生类的对象对从基类继承来的成员的访问==，==只能看到派生类public继承的的基类public成员==，其余全看访问不到。

##### 2、继承权限

> 1.public继承(都保持原样)
>
> ==公有继承==的特点是基类的==公有成员和保护成员==作为派生类的成员时，都==保持原有==的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问

> 2.protected继承(==能访问的都变为protected==)
>
> ==保护继承==的特点是基类的所有==公有成员和保护成员==都成为派生类的==保护成员==，并且==只能被它的派生类成员函数或友元函数访问==，基类的私有成员仍然是私有的，访问规则如下表。

![image-20220819181139327](E:\笔记\图片库\image-20220819181139327.png)

> 3.private继承
>
> ==私有继承==的特点是基类的所有==公有成员和保护==成员都成为派生类的==私有成员==，==并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承==，访问规则如下表

![image-20220819181150528](E:\笔记\图片库\image-20220819181150528.png)

#### 38、如何用代码判断大小端存储？

> ==Little==-Endian：==低位字节==排放在内存的==低地址端==，高位字节排放在内存的高地址端。
> ==Big-==Endian：==高位字节==排放在内存的==低地址端==，低位字节排放在内存的高地址端。
>
> 一般操作系统都是小端，而通讯协议是大端的。所有[网络协议](https://so.csdn.net/so/search?q=网络协议&spm=1001.2101.3001.7020)都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为==网络字节序==。当两台采用不同字节序的==主机通信==时，在==发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。==
>
> ###### 4.1 常见CPU的字节序
>
> Big Endian : PowerPC、IBM、Sun
> Little Endian : x86、DEC
> ARM既可以工作在大端模式，也可以工作在小端模式。
>
> 
>
> C51是大端存储；==Java==、==socket编程中网络字节序一般是大端存储==
>
> ==x86结构、DSP都是小端存储==。
>
> 
>
> 比如0x12345678在内存中的表示形式为：
> 采用大端模式：
> 低地址 --------------------> 高地址
> 0x12(==高位字节==) | 0x34 | 0x56 | 0x78(==低位字节==)
> 采用小端模式：
> 低地址 --------------------> 高地址
> 0x78 | 0x56 | 0x34 | 0x12
>
> 
>
> 大端存储：字数据的高字节存储在低地址中
>
> 小端存储：字数据的低字节存储在低地址中
>
> 例如：32bit的数字0x12345678
>
> 所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址==转换为大端存储，这样才能进行网络传输==
>
> \#define ntohs(n)   //16位数据类型网络字节顺序到主机字节顺序的转换
>
> \#define htons(n)   //16位数据类型主机字节顺序到网络字节顺序的转换
>
> \#define ntohl(n)   //32位数据类型网络字节顺序到主机字节顺序的转换
>
> \#define htonl(n)   //32位数据类型主机字节顺序到网络字节顺序的转换
>
> 



小端模式中的存储方式为：

![image-20220819183232766](E:\笔记\图片库\image-20220819183232766.png)

大端模式中的存储方式为：

![image-20220819183249057](E:\笔记\图片库\image-20220819183249057.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

方式一：使用强制类型转换

```cpp
#include <iostream>
using namespace std;
int main(){
    int a = 0x01234567;
    char b =  (char) a; //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    //char b = * (char *) &a;
    if(b == 0x67) cout<<"Little";
    else cout<<"Big";
}
```

方式二：巧用union联合体

```cpp
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
 int a;
 char ch;
};
int main()
{
 endian value;
 value.a = 0x1234;
 //a和ch共用4字节的内存空间
 if (value.ch == 0x12)
 cout << "big endian"<<endl;
 else if (value.ch == 0x34)
 cout << "little endian"<<endl; }
```

```cpp
int main(){
    union t{//共用类型foo,占用最大类型长度的整数倍(double ,8字节)，union大小为8字节。
        double i ;//double 为8字节，所以为8*2 = 16即可满足。
        char s[10];
    };
    cout<<sizeof(t);
}
--------
Outputs: 16
如果int i；那么sizeof t == 12.
```

```cpp
union foo{//最大类型长度的整数倍，并且要能容纳char
    int i;//int 4字节，所以t大小为4 * 3 =12
    char s[10];
}
OUtputs:
12
```

> **1.共用体声明和共用体变量定义**
>
> [共用体](https://baike.baidu.com/item/共用体)(参考“共用体”百科词条)是一种特殊形式的变量，使用[关键字](https://baike.baidu.com/item/关键字)union来定义
>
> 共用体(有些人也叫"联合")声明和共用体变量定义与[结构体](https://baike.baidu.com/item/结构体)十分相似。其形式为:
>
> union 共用体名{
>
> 数据类型 成员名;
>
> 数据类型 成员名;
>
> ...
>
> } 变量名;
>
> 
>
> ==共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量。在union中，所有的共用体成员共用一个空间，并且同一时间只能储存其中一个[成员变量](https://baike.baidu.com/item/成员变量)的值==。
>
> 在共用体变量bar中, 整型变量i和字符变量c==共用同一内存位置==。
> 当一个共用体被声明时, 编译程序自动地产生一个变量, 其==长度为联合中类型字节数最多的变量的类型长度的整数倍==。以上例而言，最大长度是double数据类型，所以foo的内存空间就是double型的长度。
>
> **2. 共用体和结构体的区别**
>
> [共用体](https://baike.baidu.com/item/共用体)和结构体有下列区别:
>
> 1. ==共用体和[结构体](https://baike.baidu.com/item/结构体)都是由多个不同的数据类型成员组成==, 但在任何==同一时刻==, ==共用体只存放了一个被选中的成员==, 而==结构体的所有成员都存在==。
>
> 2. 对于==共用体的不同成员赋值, 将会对其它成员重写==, 原来成员的值就不存在了, 而对于==结构体的不同成员赋值是互不影响的。==

#### 39、volatile、**mutable**和explicit关键字的用法(待看)

> ==(1)**volatile**:==
>
> volatile 关键字是一种类型修饰符，**用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：
>
> 操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当要求使用 volatile 声明的变量的值的时候，**系统总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。
>
> 
>
> ==**volatile**定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。==
>
> 
>
> **volatile** **指针**:
>
> volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念
>
> 修饰由指针指向的对象、数据是 const 或 volatile 的：
>
> `const char* cpch;volatile char* vpch;`
>
> 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：
>
> `char* const pchc;char* volatile pchv;`
>
> 注意：
>
> (1)可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。
>
> (2)除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。
>
> (3)C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用
>
> const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。
>
> 
>
> **多线程下的volatile:**
>
> 有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入****CPU****寄存器中。**如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

> ==（2）**mutable**==
>
> mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。
>
> 但是，有些时候，我们需要**在****const****函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被**mutable**修饰，并且放在函数后后面关键字位置
>
> 样例:

```cpp
const char* cpch;volatile char* vpch;

char* const pchc;char* volatile pchv;

class person

{

int m_A;

mutable int m_B;//特殊变量 在常函数里值也可以被修改

public:

 void add() const//在函数里不可修改this指针指向的值 常量指针

 {

 m_A=10;//错误 不可修改值，this已经被修饰为常量指针

 m_B=20;//正确

 }

}

class person

{

int m_A;

mutable int m_B;//特殊变量 在常函数里值也可以被修改

}

int main()

{

const person p;//修饰常对象 不可修改类成员的值

p.m_A=10;//错误，被修饰了指针常量

p.m_B=200;//正确，特殊变量，修饰了mutable

}
```

> ==（3）**explicit**==
>
> explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以**显示的方式进行类型转换**，注意以下几点：
>
> (1)explicit 关键字只能用于类内部的构造函数声明上
>
> (2)explicit 关键字作用于单个参数的构造函数
>
> (3)被explicit修饰的构造函数的类，不能发生相应的隐式类型转换

#### 40、什么情况调用拷贝函数(daikan)

> (1)用类的一个实例化对象去初始化另一个对象的时候
>
> (2)函数的参数是类的对象时（非引用传递）
>
> (3)函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
>
> **另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数**
>
> **总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数**。 
>
> 在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。
>
> **在VS2019下进行下述实验：**
>
> 举个例子：

```cpp
class A 

{

public:

 A() {};

 A(const A& a)

 {

 cout << "copy constructor is called" << endl;

 };

 ~A() {};

};

void useClassA(A a) {}

A getClassA()//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数

{

 A a;

 return a; 

}

//A& getClassA2()// VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷

贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用

//{
    // A a;
// return a;
//}
int main()
{
 A a1, a2,a3,a4;
 A a2 = a1; //调用拷贝构造函数,对应情况1
 useClassA(a1);//调用拷贝构造函数，对应情况2
 a3 = getClassA();//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3
 a4 = getClassA2(a1);//发生NRV优化，且引用返回自身，不会调用
 return 0; }
```

> 情况1比较好理解情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象
>
> 情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数

#### 41、C++的异常处理的方法

在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保

证绝对的稳定，常见的异常有：

(1)数组下标越界

(2)除法计算时除数为0

(3)动态分配空间时空间不足

...

如果不及时对这些异常进行处理，程序多数情况下都会崩溃。

**（1）try、throw和catch关键字**

C++中的异常处理机制主要使用**try**、**throw**和**catch**三个关键字，其在程序中的用法如下：

```cpp
#include <iostream>

using namespace std;

int main()

{

 double m = 1, n = 0;

 try {

 cout << "before dividing." << endl;

 if (n == 0)

 throw - 1; //抛出int型异常

 else if (m == 0)

 throw - 1.0; //拋出 double 型异常

 else

 cout << m / n << endl;

 cout << "after dividing." << endl;

 }

 catch (double d) {

 cout << "catch (double)" << d << endl;

 }

 catch (...) {

 cout << "catch (...)" << endl;

 }

 cout << "finished" << endl;

 return 0; 

}

//运行结果

//before dividing.

//catch (...)

//finished
```

> 代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是==先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块==，如果==发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息==，代码中使用的是数字，也可以自定义异常class。==catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐==）。当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。
>
> **（2）函数的异常声明列表**
>
> 有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：
>
> `int fun() throw(int,double,A,B,C){...};`
>
> 这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果==throw中为空，表明不会抛出任何异常==，如果==没有throw则可能抛出任何异常==
>
> **（3）C++标准异常类 exception**
>
> C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示
>
> ![image-20220907113040077](E:\笔记\图片库\image-20220907113040077.png)
>
> (1)bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;
class A{
public:
 virtual ~A();
};
using namespace std;
int main() {
 A* a = NULL;
 try {
 cout << typeid(*a).name() << endl; // Error condition
 }
 catch (bad_typeid){
     cout << "Object is NULL" << endl;
 }
 return 0; }
//运行结果：bject is NULL
```

> (2)bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
>
> (3)bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
>
> (4)out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常

#### 41、static的用法和作用？

> 1. 先来介绍它的第一条也是最重要的一条：==隐藏==。（static函数，static变量均可）
>
>    当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
>
> 2. static的第二个作用是==保持变量内容的持久==。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。==共有两种变量存储在静态存储区：全局变量和static变量==，只不过和全局变量比起来，==static可以控制变量的可见范围，说到底static还是用来隐藏的==。
>
> 3. static的第三个作用是==\==（static变量）
>
> ​	其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节  默认值都是0x00，某些时候这一特点可以减少程序员的工作量。
>
> 4. static的第四个作用：C++中的类成员声明static
>
> (1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
>
> (2) 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
>
> (3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内 ； 
>
> (4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
>
> (5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
>
> 类内：
>
> (6) static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类  外初始化；
>
> (7) 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指  向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问  static 修饰的类成员；
>
> (8) static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针  调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

#### 42、形参与实参的区别？

> (1)==形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元==。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
>
> (2) ==实参可以是常量、变量、表达式、函数==等， 无论实参是何种类型的量，在进行==函数调用时，它们都必须具有确定的值==， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值， 会产生一个临时变量。
>
> (3) 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
>
> (4) 函数调用中发生的==数据传送是单向的==。 即只能把==实参的值传送给形参==，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
>
> (5) 当==形参和实参不是指针类型==时，在该函数运行时，==形参和实参是不同的变量==，他们在内存中位于==不同的位置，形参将实参的内容复制一份==，在该函数运行结束的时候形参被释放，而实参内容不会改变。

#### 43、值传递、指针传递、引用传递的区别和效率

(1)==值传递==：有一个==形参向函数所属的栈拷贝数据==的过程，如果==值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）==

(2)==指针传递==：同样有一个==形参向函数所属的栈拷贝数据==的过程，但==拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）==

(3)==引用传递==：同样有上述的数据拷贝过程，但其是==针对地址==的，相当于为该==数据所在的地址起了一个别名。（传地址）==

(4)效率上讲，==指针传递和引用传递比值传递效率高==。一般==主张使用引用传递，代码逻辑上更加紧凑、清晰。==

#### 44、静态变量什么时候初始化

(1) ==初始化只有一次==，但是==可以多次赋值==，在主程序之前，编译器已经为其分配好了内存。

(2) 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配 好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部  变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。

(3) 而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始  化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的  特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并  通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对  静态局部变量进行初始化的。

#### 45、c++代码到程序的过程：

：预处理+编译+汇编+链接(c->i i->s s->o)

##### (1)预处理：

“#”开头的预处理指令：（#include，宏定义，#define），预处理器将源文件test.c预处理生成test.i文件。命令为：`gcc -E test.c -o test.i`

上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。在本例中，==预处理结果就是将stdio.h 文件中的内容插入到test.c中==了。

预处理生成的是test.i的文本文件，这个文本文件是可以直接通过cat命令进行文本文件查看的。

##### (2)编译：

这里的编译不是指程序从源文件到二进制程序的全部过程，而是指==将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程==。

编译的命令为：`gcc -S test.i -o test.s`

上述命令中-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件。

##### (3)汇编：

汇编过程将上一步的==汇编代码转换成机器码==，这一步产生的文件叫做==目标文件，是二进制格式==。

编译的命令为：`gcc -c test.s -o test.o`

##### (4)链接

链接过程==使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。==

链接过程的命令为：`gcc test.o -o test`

#### 46、const关键字的作用有哪些？(daikan)

(1) ==阻止一个变量被改变==，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因 为以后就没有机会再去改变它了；

(2) 对指针来说，可以指定==指针本身为const==，也可以指定==指针所指的数据为const==，或二者==同时指定为const==；

(3) 在一个==函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；==

(4) 对于==类的成员函数，若指定其为const类型==，则表明其==是一个常函数==，==不能修改类的成员变量，类的常对象只能访问类的常成员函数==；

(5) 对于==类的成员函数==，有时候必须指定其==返回值为const类型，以使得其返回值不为“左值”。==

(6) const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；

(7) 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；

(8) 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。

(9) const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；

(10)const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么  该变量必须在类的初始化列表中进行初始化；

(11) 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只 能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用  或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的  变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形 参无法和另一个没有顶层const的形参区分开来。

#### 47、什么是类的继承？

(1) 类与类之间的关系

==has-A包含关系==，用以描述==一个类由多个部件类构成==，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；

==use-A==，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；

==is-A，继承关系，关系具有传递性==；

(2) 继承的相关概念

所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；

(3) 继承的特点

==子类拥有父类的所有属性和方法==，子类可以==拥有父类没有的属性和方法==，==子类对象可以当做父类对象使用==；

(4) 继承中的访问控制

public、protected、private

(5)继承中的构造和析构函数

(6) 继承中的兼容性原则

#### 48、从汇编层去解释一下引用

![img](E:\笔记\图片库\wps4.png) 

==x的地址为ebp-4，b的地址为ebp-8==，因为栈内的变量内存是==从高往低进行分配==的，所以==b的地址比x的低==。

lea eax,[ebp-4] 这条语句将==x的地址ebp-4放入eax寄存器==

mov dword ptr [ebp-8],eax 这条语句==将eax的值放入b的地址==

ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样  的吗？所以从汇编层次来看，的确引用是通过指针来实现的。

#### 49、深拷贝与浅拷可以描述一下吗？

浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，  那么浅复制出来的对象也会相应改变。

深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。

在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给  另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也 指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，  出现运行错误。
